// Транскомпиляторы transpiling - термин образован от transformation (преобразование) и compiling(компиляция)

// var foo = [1,2,3]
// var obj = {
// 	foo
// }
// console.log(obj.foo)

// SHIM Библиотеки (полизаполнения - polyfills) - представляют собой шаблоны для определения поведений из новой среды для более старых сред
//  новый метод Object.is()
//  === Объявление на уровне блоков кода === стр.25
// IIFE - немедленно вызываемая функция. Immediately invoked function expression. Сразу вызываемое выражение функции - это идиома языка программирования, которая создает лексическую область видимости с использованием области видимости функции. Он был популярен в JavaScript как метод поддержки модульного программирования до появления более стандартизованных решений, таких как модули CommonJS и ES.
// var a = 2;
// (function IIFE() {
// 	var a = 3 ;
// 	console.log(a);
// })();
// console.log(a);

// === Оператор LET === стр.25
// Объявление связанное с произвольным блоком кода. Называется блочной областью видимости - BLOCK SCOPING
// var a = 2;
// {
// 	let a = 3
// 	console.log(a);
// }
// console.log(a);
// Оператор LET всегда должен находиться в верхней части кода, причем желательно чтобы он был один вне зависимости от количества объявленных переменных.
// {
// 	let a = 2, b, c, d = 3;
// }
// экспериментальная(не входящая в стандарт) форма объявления при помощи оператора LET называется LET - блоком.
// let (a = 2, b, c, d = 3;) {
// 	console.log(a);
// }
// НЕЯВНАЯ ПРИРОДА ОБЪЯВЛЕНИЯ переменных
// let a = 2

// if (a > 1) {
// 	let b = a * 3
// 	// console.log(b)
// 	for (let i = a; i <= b; i++) {
// 		// console.log(i)
// 		let j = i + 10
// 		// console.log(j)
// 	}
// 	let c = a + b
// 	// console.log(c)
// }
//  помещать объявление С так низко не безопасно, если переменные объявленные с помощью глобальной области видимости VAR связываются независимо от своего расположения, то LET связывает переменную с областью видимости блока, но инициализация произойдет только после объявления этой переменной.
// {
// 	console.log(a);
// 	console.log(b)

// 	let a; // ReferenceError - технически называется ошибкой временной мертвой зоны TDZ (TEMPORAL DEAD ZONE)
// 	var b;
// }

// Ещё одна ошибка МЕРТВОЙ ЗОНЫ оператор typeof ведет себя не так как с необъявленными или объявленными переменными например:
// {
// 	// переменная а не объявлена
// 	if(typeof a === 'undefined') {
// 		console.log('cool')
// 	}
// 	// переменная b объявлена, но находится в мертвой зоне
// 	if(typeof b === 'undefined'){}

// 	let b;
// }
// Переменная а не была объявлена так что единственный безопасный способ проверить, существует она или нет - использовать оператор typeof. При этом запись typeof b приводит к появлению ошибки TDZ - временной мертвой зоны так как строчка let b объявляющая переменную располагается ниже.

// === Оператор LET и цикл FOR === стр.30
// Единственный случай когда лучше отказаться от явной формы объявления блочной области видимости с помощью оператора let это его вставка в заголовок цикла for. Пример:
// var funcs = []

// for(var i = 0; i < 5; i++){
// 	funcs.push(function(){
// 		console.log(i)
// 	})
// }

// funcs[3]() // 3
// оператор let i в заголовке цикла for объявляет переменную i на каждой итерации. Если вставить в заголовок цикла for выражение var i = 0; - получим значение 5 вместо 3 так как в этом случае замыканию будет подвергаться только переменная i во внешней области видимости, а не новая i для каждой итерации.

// === Объявления с оператором const === стр.31
// CONST - константа это переменная которая после присвоения начального значения доступна только для чтения. Например:
// {
// 	const b = undefined;
// 	const a = 2;
// 	console.log(a, b)

// 	a = 3; // TypeError
// }
// Нельзя менять значение такой переменной после того как задали его во время объявления. Объявление при помощи const всегда должно сопровождаться инициализацией. Если требуется константа со значение undefined, нужно задать его явно const a = undefined; В случае констант ограничение накладывается не на их ЗНАЧЕНИЕ а на операцию присваивания. Значение оказывается неизменяемым из-за невозможности присваивания другого значения. Если значение комплексное например в случае массива или объекта допускается модификация, пример:
// {
// 	const a = [1, 2, 3, 4];
// 	a.push(6,7)
// 	console.log(a)

// 	a = 42 // TypeError
// }
// Переменная a содержит НЕ КОНСТАНТнЫЙ МАССИВ, а неизменяемую ссылку на него. Однако сам массив допускает модификацию.

// === Функции с областью видимости на уровне блока стр.33 ===
//  Начиная с ES6 область видимости объявленных внутри блока функций ограничивается этим блоком. Ранее подобного поведения спецификация не предусматривала. Пример:
// {
// 	foo(10) // works!

// 	function foo() {
// 		const a = 3
// 		console.log(a)
// 	}
// 	// if (true) {
// 	// 	const message = 'hello'
// 	// 	console.log(message)
// 	// }
// }
// // console.log(message) // ReferenceError раньше область видимости ограничивалась
// foo();

// // var не имеет блочной области видимости
// if (true) {
//     // область видимости блока if
//     var count = 0
//     console.log(count) // 0
// }
// console.log(count) // 0
// Переменная count, как и ожидалось, доступна внутри блока if. Однако, она доступна и за пределами данного блока! Дело в том, что блок кода не создает области видимости для переменных, объявленных с помощью ключевого слова var. Но это делает функция.

//  Область видимости функции. Функции в JavaScript создают область видимости для всех переменных, независимо от того, с помощью какого ключевого слова они объявлены (var, const или let). Например:
// function run() {
//     // область видимости функции run()
//     var message = 'Беги, Форрест, беги!'
//     console.log(message)
// }
// run() // 'Беги, Форрест, беги!'
// console.log(message) // ReferenceError

// ПРАВИЛО!!! Переменные из внешней области видимости доступны во внутренней области.

// Глобальная область видимости
// script.js
// глобальная область видимости
// let counter = 1
// Переменные, объявленные в глобальной области видимости являются глобальными переменными. Они доступны в любой другой области.
// Глобальная область видимости — это механизм, который позволяет среде выполнения JavaScript-кода (браузеру, Node.js) предоставлять приложениям хостовые (т.е. принадлежащие среде) объекты как глобальные переменные.
// Например, window и document являются глобальными переменными (объектами), предоставляемыми браузером. В Node.js такой переменной является, например, объект process.

// Лексическая область видимости
// Определим две функции, одна из которых вложена в другую:

// function outer() {
//     // область видимости функции outer()
//     let v = 'Я из области видимости функции outer()!'

//     function inner() {
//         // область видимости функции inner()
//         console.log(v) // 'Я из области видимости функции outer()!'
//     }

//     return inner
// }

// const f = outer()
// f()
// Взгляните на последнюю строку: функция inner() вызывается за пределами области видимости функции outer(). Как JavaScript понимает, что значение, выводимое в консоль в функции inner(), принадлежит переменной v, объявленной в фукнции outer()?

// Ответ: благодаря лексической области видимости.

// JavaScript реализует механизм под названием лексическая или статическая область видимости. Лексическая область видимости означает, что доступность переменных определяется статически положением данных переменных внутри области видимости вложенной функции: переменные из области видимости внешней функции доступны в области видимости вложенной функции.
// Формальное определение лексической области гласит следующее:
// Лексическая область видимости состоит из внешних областей видимости, определенных статически, т.е. из внешних областей, зафиксированных использованием переменных из этих областей во внутренних функциях.
// В приведенном примере лексическая область видимости функции inner() состоит из области видимости функции outer().
// Более того, inner() — это замыкание, поскольку в ней используется значение переменной из лексической области видимости.