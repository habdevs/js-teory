---
# 2.1 Привет, мир!

## Итого

<p>

- Для добавления кода JavaScript на страницу используется тег `<script>`
- Атрибуты type и language необязательны.
- Скрипт во внешнем файле можно вставить с помощью `<script src="path/to/script.js"></script>`
</p>
---

# 2.2 Структура кода

### Что такое инструкции?

<details><summary><b>Ответ</b></summary>
<p>

- Инструкции – это синтаксические конструкции и команды, которые выполняют действия.
- В нашем коде может быть столько инструкций, сколько мы захотим. Инструкции могут отделяться точкой с запятой.
- В большинстве случаев точку с запятой можно не ставить, если есть переход на новую строку. В этом случае JavaScript интерпретирует перенос строки как <em>«неявную»</em> точку с запятой. Это называется автоматическая вставка точки с запятой.
- JavaScript не вставляет точку с запятой перед квадратными скобками `[...].` И поэтому код выполняется, как одна инструкция.
</p>
</details>
 <br/>

---

# 2.3 Строгий режим — "use strict"

<p>
На протяжении долгого времени JavaScript развивался без проблем с обратной совместимостью. Новые функции добавлялись в язык, в то время как старая функциональность не менялась.

Преимуществом данного подхода было то, что существующий код продолжал работать. А недостатком – что любая ошибка или несовершенное решение, принятое создателями JavaScript, застревали в языке навсегда.

Так было до 2009 года, когда появился ECMAScript 5 (ES5). Он добавил новые возможности в язык и изменил некоторые из существующих. Чтобы устаревший код работал, как и раньше, по умолчанию подобные изменения не применяются. Поэтому нам нужно явно их активировать с помощью специальной директивы: "use strict".

</p>	
<br/>

### Всегда ли нужно использовать «use strict»?

<details><summary><b>Ответ</b></summary>
<p>

- Кто-то посоветует начинать каждый скрипт с "use strict"… Но есть способ покруче.
- Современный JavaScript поддерживает «классы» и «модули» — продвинутые структуры языка (и мы, конечно, до них доберёмся), которые автоматически включают строгий режим. Поэтому в них нет нужды добавлять директиву "use strict".
- Подытожим: пока очень желательно добавлять "use strict"; в начале ваших скриптов. Позже, когда весь ваш код будет состоять из классов и модулей, директиву можно будет опускать.
- Пока мы узнали о use strict только в общих чертах.
- В следующих главах, по мере расширения знаний о возможностях языка, мы яснее увидим отличия между строгим и стандартным режимом. К счастью, их не так много, и все они делают жизнь разработчика лучше.
- Все примеры в этом учебнике подразумевают исполнение в строгом режиме, за исключением случаев (очень редких), когда оговорено иное.
</p>
</details>
<br/>

---

# 2.4 Переменные

### Что такое переменная?

<details><summary><b>Ответ</b></summary>
<p>

- Переменная – это «именованное хранилище» для данных. Мы можем использовать переменные для хранения товаров, посетителей и других данных.
- Для создания переменной в JavaScript используйте ключевое слово let.
- Приведённая ниже инструкция создаёт (другими словами: объявляет или определяет) переменную с именем «message»:
- Переменная может быть объявлена только один раз.
- Повторное объявление той же переменной является ошибкой:

```javascript
let message
```

</p>
</details>
<br/>

### Какие ограничения есть в именовании переменных?

<details><summary><b>Ответ</b></summary>
<p>

- Имя переменной должно содержать только буквы, цифры или символы $ и \_.
- Первый символ не должен быть цифрой.
- Примеры допустимых имен

```javascript
let userName
let test123
```

- Если имя содержит несколько слов, обычно используется верблюжья нотация, то есть, слова следуют одно за другим, где каждое следующее слово начинается с заглавной буквы: myVeryLongName.
- Самое интересное – знак доллара '$' и подчёркивание '\_' также можно использовать в названиях. Это обычные символы, как и буквы, без какого-либо особого значения.

```javascript
let $ = 1 // объявили переменную с именем "$"
let _ = 2 // а теперь переменную с именем "_"
alert($ + _) // 3
```

- Регистр имеет значение!
- Переменные с именами apple и APPLE – это две разные переменные.

</p>
</details>
<br/>

### Ключевые слова (зарезервированные)

<details><summary><b>Ответ</b></summary>
<p>

- Ключевые слова:
  break
  case
  class
  catch
  const
  continue
  debugger
  default
  delete
  do
  else
  export
  extends
  finally
  for
  function
  if
  import
  in
  instanceof
  let
  new
  return
  super
  switch
  this
  throw
  try
  typeof
  var
  void
  while
  with
  yield

- Ключевые слова, зарезервированные на будущее
  Следующие ключевые слова зарезервированы на будущее ECMAScript спецификацией. За ними сейчас не стоит никакой функциональности, но она может появиться в будущих версиях, поэтому эти ключевые слова не могут быть использованы, как идентификаторы. Эти ключевые слова не могут быть использованы даже в strict или non-strict режимах.
  enum
  await

- Следующие ключевые слова зарезервированы для кода, который выполняется в strict режиме:

implements
package
protected
static
interface
private
public

- Зарезервированные ключевые слова в более старых версиях
  Перечисленные ниже ключевые слова зарезервированы для старых версий ECMAScript спецификаций (ECMAScript от 1 по 3).

abstract
boolean
byte
char
double
final
float
goto
int
long
native
short
synchronized
transient
volatile

- К тому же, литералы null, true, и false зарезервированы в ECMAScript для их обычной функциональности.
</p>
</details>
<br/>

### Константы

<details><summary><b>Ответ</b></summary>
<p>
Чтобы объявить константную, то есть, неизменяемую переменную, используйте `const` вместо `let`:

```js
const myBirthday = '18.04.1982'
```

Переменные, объявленные с помощью `const`, называются "константами". Их нельзя изменить. Попытка сделать это приведёт к ошибке:

```js run
const myBirthday = '18.04.1982'

myBirthday = '01.01.2001' // ошибка, константу нельзя перезаписать!
```

Если программист уверен, что переменная никогда не будет меняться, он может гарантировать это и наглядно донести до каждого, объявив её через `const`.

### Константы в верхнем регистре

Широко распространена практика использования констант в качестве псевдонимов для трудно запоминаемых значений, которые известны до начала исполнения скрипта.

Названия таких констант пишутся с использованием заглавных букв и подчёркивания.

Например, сделаем константы для различных цветов в "шестнадцатеричном формате":

```js run
const COLOR_RED = '#F00'
const COLOR_GREEN = '#0F0'
const COLOR_BLUE = '#00F'
const COLOR_ORANGE = '#FF7F00'

// ...когда нам нужно выбрать цвет
let color = COLOR_ORANGE
alert(color) // #FF7F00
```

Преимущества:

- `COLOR_ORANGE` гораздо легче запомнить, чем `"#FF7F00"`.
- Гораздо легче допустить ошибку при вводе `"#FF7F00"`, чем при вводе `COLOR_ORANGE`.
- При чтении кода `COLOR_ORANGE` намного понятнее, чем `#FF7F00`.

Когда мы должны использовать для констант заглавные буквы, а когда называть их нормально? Давайте разберёмся и с этим.

Название "константа" просто означает, что значение переменной никогда не меняется. Но есть константы, которые известны до выполнения (например, шестнадцатеричное значение для красного цвета), а есть константы, которые _вычисляются_ во время выполнения сценария, но не изменяются после их первоначального назначения.

Например:

```js
const pageLoadTime = /* время, потраченное на загрузку веб-страницы */;
```

Значение `pageLoadTime` неизвестно до загрузки страницы, поэтому её имя записано обычными, а не прописными буквами. Но это всё ещё константа, потому что она не изменяется после назначения.

Другими словами, константы с именами, записанными заглавными буквами, используются только как псевдонимы для "жёстко закодированных" значений.

## Придумывайте правильные имена

В разговоре о переменных необходимо упомянуть, что есть ещё одна чрезвычайно важная вещь.

Название переменной должно иметь ясный и понятный смысл, говорить о том, какие данные в ней хранятся.

Именование переменных -- это один из самых важных и сложных навыков в программировании. Быстрый взгляд на имена переменных может показать, какой код был написан новичком, а какой -- опытным разработчиком.

В реальном проекте большая часть времени тратится на изменение и расширение существующей кодовой базы, а не на написание чего-то совершенно нового с нуля. Когда мы возвращаемся к коду после какого-то промежутка времени, гораздо легче найти информацию, которая хорошо размечена. Или, другими словами, когда переменные имеют хорошие имена.

Пожалуйста, потратьте время на обдумывание правильного имени переменной перед её объявлением. Делайте так, и будете вознаграждены.

Несколько хороших правил:

- Используйте легко читаемые имена, такие как `userName` или `shoppingCart`.
- Избегайте использования аббревиатур или коротких имён, таких как `a`, `b`, `c`, за исключением тех случаев, когда вы точно знаете, что так нужно.
- Делайте имена максимально описательными и лаконичными. Примеры плохих имён: `data` и `value`. Такие имена ничего не говорят. Их можно использовать только в том случае, если из контекста кода очевидно, какие данные хранит переменная.
- Договоритесь с вашей командой об используемых терминах. Если посетитель сайта называется "user", тогда мы должны называть связанные с ним переменные `currentUser` или `newUser`, а не, к примеру, `currentVisitor` или `newManInTown`.

Звучит просто? Действительно, это так, но на практике для создания описательных и кратких имён переменных зачастую требуется подумать. Действуйте.

```smart header="Повторно использовать или создавать новую переменную?"
И последняя заметка. Есть ленивые программисты, которые вместо объявления новых переменных повторно используют существующие.

В результате их переменные похожи на коробки, в которые люди бросают разные предметы, не меняя на них этикетки. Что сейчас находится внутри коробки? Кто знает? Нам необходимо подойти поближе и проверить.

Такие программисты немного экономят на объявлении переменных, но теряют в десять раз больше при отладке.

Дополнительная переменная - это добро, а не зло.

Современные JavaScript-минификаторы и браузеры оптимизируют код достаточно хорошо, поэтому он не создаёт проблем с производительностью. Использование разных переменных для разных значений может даже помочь движку оптимизировать ваш код.
```

</p>
</details>
<br/>

## Итого

Мы можем объявить переменные для хранения данных с помощью ключевых слов `var`, `let` или `const`.

- `let` -- это современный способ объявления.
- `var` -- это устаревший способ объявления. Обычно мы вообще не используем его, но мы рассмотрим тонкие отличия от `let` в главе <info:var> на случай, если это всё-таки вам понадобится.
- `const` -- похоже на `let`, но значение переменной не может изменяться.

Переменные должны быть названы таким образом, чтобы мы могли легко понять, что у них внутри.
<br/>

---

# 2.5 Типы данных

### Число

<details><summary><b>Ответ</b></summary>
<p>

```js
let n = 123
n = 12.345
```

_Числовой_ тип данных (`number`) представляет как целочисленные значения, так и числа с плавающей точкой.

Существует множество операций для чисел, например, умножение `*`, деление `/`, сложение `+`, вычитание `-` и так далее.

Кроме обычных чисел, существуют так называемые "специальные числовые значения", которые относятся к этому типу данных: `Infinity`, `-Infinity` и `NaN`.

- `Infinity` представляет собой математическую [бесконечность](https://ru.wikipedia.org/wiki/Бесконечность#В_математике) ∞. Это особое значение, которое больше любого числа.

  Мы можем получить его в результате деления на ноль:

  ```js run
  alert(1 / 0) // Infinity
  ```

  Или задать его явно:

  ```js run
  alert(Infinity) // Infinity
  ```

- `NaN` означает вычислительную ошибку. Это результат неправильной или неопределённой математической операции, например:

  ```js run
  alert('не число' / 2) // NaN, такое деление является ошибкой
  ```

  Значение `NaN` "прилипчиво". Любая математическая операция с `NaN` возвращает `NaN`:

  ```js run
  alert(NaN + 1) // NaN
  alert(3 * NaN) // NaN
  alert('не число' / 2 - 1) // NaN
  ```

- Если где-то в математическом выражении есть `NaN`, то оно распространяется на весь результат (есть только одно исключение: `NaN ** 0` равно `1`).
- Удобство функции isNaN
  В отличие от всех других возможных значений в JavaScript, невозможно использовать операторы равенства (== и ===) для сравнения значения с NaN, чтобы определить, является ли значение NaN или нет, поскольку и NaN == NaN, и NaN === NaN имеют значение false. Функция isNaN() обеспечивает удобную проверку равенства NaN.

```js run
isNaN(NaN) // true
isNaN(undefined) // true
isNaN({}) // true

isNaN(true) // false
isNaN(null) // false
isNaN(37) // false

// strings
isNaN('37') // false: "37" is converted to the number 37 which is not NaN
isNaN('37.37') // false: "37.37" is converted to the number 37.37 which is not NaN
isNaN('37,5') // true
isNaN('123ABC') // true:  parseInt("123ABC") is 123 but Number("123ABC") is NaN
isNaN('') // false: the empty string is converted to 0 which is not NaN
isNaN(' ') // false: a string with spaces is converted to 0 which is not NaN

// dates
isNaN(new Date()) // false
isNaN(new Date().toString()) // true

// This is a false positive and the reason why isNaN is not entirely reliable
isNaN('blabla') // true: "blabla" is converted to a number.
// Parsing this as a number fails and returns NaN
```

</p>
</details>
<br/>

## BigInt

<details><summary><b>Ответ</b></summary>
<p>

В JavaScript тип `number` не может безопасно работать с числами, большими, чем <code>(2<sup>53</sup>-1)</code> (т. е. `9007199254740991`) или меньшими, чем <code>-(2<sup>53</sup>-1)</code> для отрицательных чисел. Технически, тип `number` может хранить и гораздо большие значения (вплоть до <code>1.7976931348623157 \* 10<sup>308</sup></code>), однако за пределами безопасного диапазона <code>±(2<sup>53</sup>-1)</code> многие из чисел не могут быть представлены с помощью этого типа данных из-за ограничений, вызванных внутренним представлением чисел в двоичной форме. Например, нечётные числа, большие, чем <code>(2<sup>53</sup>-1)</code>, невозможно хранить при помощи типа `number`, они с разной точностью будут автоматически округляться до чётных значений. В то же время некоторые чётные числа, большие, чем <code>(2<sup>53</sup>-1)</code>, при помощи типа `number` хранить технически возможно (однако не стоит этого делать во избежание дальнейших ошибок).

Для большинства случаев достаточно безопасного диапазона чисел от <code>-(2<sup>53</sup>-1)</code> до <code>(2<sup>53</sup>-1)</code>. Но иногда нам нужен диапазон действительно гигантских целых чисел без каких-либо ограничений или пропущенных значений внутри него. Например, в криптографии или при использовании метки времени ("timestamp") с микросекундами.

Тип `BigInt` был добавлен в JavaScript, чтобы дать возможность работать с целыми числами произвольной длины.

Чтобы создать значение типа `BigInt`, необходимо добавить `n` в конец числового литерала:

```js
// символ "n" в конце означает, что это BigInt
const bigInt = 1234567890123456789012345678901234567890n
```

Так как `BigInt`-числа нужны достаточно редко, мы рассмотрим их в отдельной главе <info:bigint>. Ознакомьтесь с ней, когда вам понадобятся настолько большие числа.

```smart header="Поддержка"
В данный момент `BigInt` поддерживается только в браузерах Firefox, Chrome, Edge и Safari, но не поддерживается в IE.
```

</p>
</details>
<br/>

## Строка

<details><summary><b>Ответ</b></summary>
<p>

Строка (`string`) в JavaScript должна быть заключена в кавычки.

```js
let str = 'Привет'
let str2 = 'Одинарные кавычки тоже подойдут'
let phrase = `Обратные кавычки позволяют встраивать переменные ${str}`
```

В JavaScript существует три типа кавычек.

1. Двойные кавычки: `"Привет"`.
2. Одинарные кавычки: `'Привет'`.
3. Обратные кавычки: <code>&#96;Привет&#96;</code>.

Двойные или одинарные кавычки являются "простыми", между ними нет разницы в JavaScript.

Обратные же кавычки имеют расширенную функциональность. Они позволяют нам встраивать выражения в строку, заключая их в `${…}`. Например:

```js run
let name = 'Иван'

// Вставим переменную
alert(`Привет, *!*${name}*/!*!`) // Привет, Иван!

// Вставим выражение
alert(`результат: *!*${1 + 2}*/!*`) // результат: 3
```

Выражение внутри `${…}` вычисляется, и его результат становится частью строки. Мы можем положить туда всё, что угодно: переменную `name`, или выражение `1 + 2`, или что-то более сложное.

Обратите внимание, что это можно делать только в обратных кавычках. Другие кавычки не имеют такой функциональности встраивания!

```js run
alert('результат: ${1 + 2}') // результат: ${1 + 2} (двойные кавычки ничего не делают)
```

Мы рассмотрим строки более подробно в главе <info:string>.

```smart header="Нет отдельного типа данных для одного символа."
В некоторых языках, например C и Java, для хранения одного символа, например `"a"` или `"%"`, существует отдельный тип. В языках C и Java это `char`.

В JavaScript подобного типа нет, есть только тип `string`. Строка может содержать ноль символов (быть пустой), один символ или множество.
```

</p>
</details>
<br/>

## Булевый (логический) тип

<details><summary><b>Ответ</b></summary>
<p>

Булевый тип (`boolean`) может принимать только два значения: `true` (истина) и `false` (ложь).

Такой тип, как правило, используется для хранения значений да/нет: `true` значит "да, правильно", а `false` значит "нет, не правильно".

Например:

```js
let nameFieldChecked = true // да, поле отмечено
let ageFieldChecked = false // нет, поле не отмечено
```

Булевые значения также могут быть результатом сравнений:

```js run
let isGreater = 4 > 1

alert(isGreater) // true (результатом сравнения будет "да")
```

Мы рассмотрим булевые значения более подробно в главе <info:logical-operators>.

</p>
</details>
<br/>

## Значение "null"

<details><summary><b>Ответ</b></summary>
<p>

Специальное значение `null` не относится ни к одному из типов, описанных выше.

Оно формирует отдельный тип, который содержит только значение `null`:

```js
let age = null
```

В JavaScript `null` не является "ссылкой на несуществующий объект" или "нулевым указателем", как в некоторых других языках.

Это просто специальное значение, которое представляет собой "ничего", "пусто" или "значение неизвестно".

В приведённом выше коде указано, что значение переменной `age` неизвестно.

</p>
</details>
<br/>

## Значение "undefined"

<details><summary><b>Ответ</b></summary>
<p>

Специальное значение `undefined` также стоит особняком. Оно формирует тип из самого себя так же, как и `null`.

Оно означает, что "значение не было присвоено".

Если переменная объявлена, но ей не присвоено никакого значения, то её значением будет `undefined`:

```js run
let age

alert(age) // выведет "undefined"
```

Технически мы можем присвоить значение `undefined` любой переменной:

```js run
let age = 123

// изменяем значение на undefined
age = undefined

alert(age) // "undefined"
```

...Но так делать не рекомендуется. Обычно `null` используется для присвоения переменной "пустого" или "неизвестного" значения, а `undefined` -- для проверок, была ли переменная назначена.

</p>
</details>
<br/>

## Объекты и символы

<details><summary><b>Ответ</b></summary>
<p>

Тип `object` (объект) -- особенный.

Все остальные типы называются "примитивными", потому что их значениями могут быть только простые значения (будь то строка, или число, или что-то ещё). В объектах же хранят коллекции данных или более сложные структуры.

Объекты занимают важное место в языке и требуют особого внимания. Мы разберёмся с ними в главе <info:object> после того, как узнаем больше о примитивах.

Тип `symbol` (символ) используется для создания уникальных идентификаторов в объектах. Мы упоминаем здесь о нём для полноты картины, изучим этот тип после объектов.

</p>
</details>
<br/>

## Оператор typeof [#type-typeof]

<details><summary><b>Ответ</b></summary>
<p>

Оператор `typeof` возвращает тип аргумента. Это полезно, когда мы хотим обрабатывать значения различных типов по-разному или просто хотим сделать проверку.

У него есть две синтаксические формы:

1. Синтаксис оператора: `typeof x`.
2. Синтаксис функции: `typeof(x)`.

Другими словами, он работает со скобками или без скобок. Результат одинаковый.

Вызов `typeof x` возвращает строку с именем типа:

```js
typeof undefined // "undefined"

typeof 0 // "number"

typeof 10n // "bigint"

typeof true // "boolean"

typeof "foo" // "string"

typeof Symbol("id") // "symbol"

*!*
typeof Math // "object"  (1)
*/!*

*!*
typeof null // "object"  (2)
*/!*

*!*
typeof alert // "function"  (3)
*/!*
```

Последние три строки нуждаются в пояснении:

1. `Math` — это встроенный объект, который предоставляет математические операции и константы. Мы рассмотрим его подробнее в главе <info:number>. Здесь он служит лишь примером объекта.
2. Результатом вызова `typeof null` является `"object"`. Это официально признанная ошибка в `typeof`, ведущая начало с времён создания JavaScript и сохранённая для совместимости. Конечно, `null` не является объектом. Это специальное значение с отдельным типом.
3. Вызов `typeof alert` возвращает `"function"`, потому что `alert` является функцией. Мы изучим функции в следующих главах, где заодно увидим, что в JavaScript нет специального типа "функция". Функции относятся к объектному типу. Но `typeof` обрабатывает их особым образом, возвращая `"function"`. Так тоже повелось от создания JavaScript. Формально это неверно, но может быть удобным на практике.
</p>
</details>
<br/>

## Итого

В JavaScript есть 8 основных типов данных.

- Семь из них называют «примитивными» типами данных:
  - `number` для любых чисел: целочисленных или чисел с плавающей точкой; целочисленные значения ограничены диапазоном <code>±(2<sup>53</sup>-1)</code>.
  - `bigint` для целых чисел произвольной длины.
  - `string` для строк. Строка может содержать ноль или больше символов, нет отдельного символьного типа.
  - `boolean` для `true`/`false`.
  - `null` для неизвестных значений -- отдельный тип, имеющий одно значение `null`.
  - `undefined` для неприсвоенных значений -- отдельный тип, имеющий одно значение `undefined`.
  - `symbol` для уникальных идентификаторов.
- И один не является «примитивным» и стоит особняком:
  - `object` для более сложных структур данных.

Оператор `typeof` позволяет нам увидеть, какой тип данных сохранён в переменной.

- Имеет две формы: `typeof x` или `typeof(x)`.
- Возвращает строку с именем типа. Например, `"string"`.
- Для `null` возвращается `"object"` -- это ошибка в языке, на самом деле это не объект.
  <br/>

---

# 2.6 Взаимодействие: alert, prompt, confirm

### Взаимодействие: alert, prompt, confirm

<details><summary><b>Ответ</b></summary>
<p>

Так как мы будем использовать браузер как демо-среду, нам нужно познакомиться с несколькими функциями его интерфейса, а именно: `alert`, `prompt` и `confirm`.

## alert

С этой функцией мы уже знакомы. Она показывает сообщение и ждёт, пока пользователь нажмёт кнопку "ОК".

Например:

```js run
alert('Hello')
```

Это небольшое окно с сообщением называется _модальным окном_. Понятие _модальное_ означает, что пользователь не может взаимодействовать с интерфейсом остальной части страницы, нажимать на другие кнопки и т.д. до тех пор, пока взаимодействует с окном. В данном случае -- пока не будет нажата кнопка "OK".

## prompt

Функция `prompt` принимает два аргумента:

```js no-beautify
result = prompt(title, [default]);
```

Этот код отобразит модальное окно с текстом, полем для ввода текста и кнопками OK/Отмена.

`title`
: Текст для отображения в окне.

`default`
: Необязательный второй параметр, который устанавливает начальное значение в поле для текста в окне.

```smart header="Квадратные скобки в синтаксисе `[...]`" Квадратные скобки вокруг `default` в описанном выше синтаксисе означают, что параметр факультативный, необязательный.

````

Пользователь может напечатать что-либо в поле ввода и нажать OK. Введённый текст будет присвоен переменной `result`. Пользователь также может отменить ввод нажатием на кнопку "Отмена" или нажав на клавишу `key:Esc`. В этом случае значением `result` станет  `null`.

Вызов `prompt` возвращает текст, указанный в поле для ввода, или `null`, если ввод отменён пользователем.

Например:

```js run
let age = prompt('Сколько тебе лет?', 100);

alert(`Тебе ${age} лет!`); // Тебе 100 лет!
````

````warn header="Для IE: всегда устанавливайте значение по умолчанию"
Второй параметр является необязательным, но если не указать его, то Internet Explorer вставит строку `"undefined"` в поле для ввода.

Запустите код в Internet Explorer и посмотрите на результат:

```js run
let test = prompt("Test");
```

Чтобы `prompt` хорошо выглядел в IE, рекомендуется всегда указывать второй параметр:

```js run
let test = prompt("Test", ''); // <-- для IE
```
````

## confirm

Синтаксис:

```js
result = confirm(question)
```

Функция `confirm` отображает модальное окно с текстом вопроса `question` и двумя кнопками: OK и Отмена.

Результат -- `true`, если нажата кнопка OK. В других случаях -- `false`.

Например:

```js run
let isBoss = confirm('Ты здесь главный?')

alert(isBoss) // true, если нажата OK
```

## Итого

Мы рассмотрели 3 функции браузера для взаимодействия с пользователем:

`alert`
: показывает сообщение.

`prompt`
: показывает сообщение и запрашивает ввод текста от пользователя. Возвращает напечатанный в поле ввода текст или `null`, если была нажата кнопка "Отмена" или `key:Esc` с клавиатуры.

`confirm`
: показывает сообщение и ждёт, пока пользователь нажмёт OK или Отмена. Возвращает `true`, если нажата OK, и `false`, если нажата кнопка "Отмена" или `key:Esc` с клавиатуры.

Все эти методы являются модальными: останавливают выполнение скриптов и не позволяют пользователю взаимодействовать с остальной частью страницы до тех пор, пока окно не будет закрыто.

На все указанные методы распространяются два ограничения:

1. Расположение окон определяется браузером. Обычно окна находятся в центре.
2. Визуальное отображение окон зависит от браузера, и мы не можем изменить их вид.

Такова цена простоты. Есть другие способы показать более приятные глазу окна с богатой функциональностью для взаимодействия с пользователем, но если "навороты" не имеют значения, то данные методы работают отлично.

</p>
</details>
<br/>

---

# 2.7 Преобразование типов

<details><summary><b>Ответ</b></summary>
<p>

# Преобразование типов

Чаще всего операторы и функции автоматически приводят переданные им значения к нужному типу.

Например, `alert` автоматически преобразует любое значение к строке. Математические операторы преобразуют значения к числам.

Есть также случаи, когда нам нужно явно преобразовать значение в ожидаемый тип.

```smart header="Пока что мы не говорим об объектах"
В этой главе мы не касаемся объектов. Сначала мы разберём преобразование примитивных значений.

Мы разберём преобразование объектов позже, в главе <info:object-toprimitive>.
```

## Строковое преобразование

Строковое преобразование происходит, когда требуется представление чего-либо в виде строки.

Например, `alert(value)` преобразует значение к строке.

Также мы можем использовать функцию `String(value)`, чтобы преобразовать значение к строке:

```js run
let value = true;
alert(typeof value); // boolean

*!*
value = String(value); // теперь value это строка "true"
alert(typeof value); // string
*/!*
```

Преобразование происходит очевидным образом. `false` становится `"false"`, `null` становится `"null"` и т.п.

## Численное преобразование

Численное преобразование происходит в математических функциях и выражениях.

Например, когда операция деления `/` применяется не к числу:

```js run
alert('6' / '2') // 3, строки преобразуются в числа
```

Мы можем использовать функцию `Number(value)`, чтобы явно преобразовать `value` к числу:

```js run
let str = '123'
alert(typeof str) // string

let num = Number(str) // становится числом 123

alert(typeof num) // number
```

Явное преобразование часто применяется, когда мы ожидаем получить число из строкового контекста, например из текстовых полей форм.

Если строка не может быть явно приведена к числу, то результатом преобразования будет `NaN`. Например:

```js run
let age = Number('Любая строка вместо числа')

alert(age) // NaN, преобразование не удалось
```

Правила численного преобразования:

| Значение                            | Преобразуется в...                                                                                                                                                                                                                      |
| ----------------------------------- | --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| `undefined`                         | `NaN`                                                                                                                                                                                                                                   |
| `null`                              | `0`                                                                                                                                                                                                                                     |
| <code>true&nbsp;/&nbsp;false</code> | `1` / `0`                                                                                                                                                                                                                               |
| `string`                            | Пробельные символы (пробелы, знаки табуляции `\t`, знаки новой строки `\n` и т. п.) по краям обрезаются. Далее, если остаётся пустая строка, то получаем `0`, иначе из непустой строки "считывается" число. При ошибке результат `NaN`. |

Примеры:

```js run
alert(Number('   123   ')) // 123
alert(Number('123z')) // NaN (ошибка чтения числа на месте символа "z")
alert(Number(true)) // 1
alert(Number(false)) // 0
```

Учтите, что `null` и `undefined` ведут себя по-разному. Так, `null` становится нулём, тогда как `undefined` приводится к `NaN`.

Большинство математических операторов также производит данное преобразование, как мы увидим в следующей главе.

## Логическое преобразование

Логическое преобразование самое простое.

Происходит в логических операциях (позже мы познакомимся с условными проверками и подобными конструкциями), но также может быть выполнено явно с помощью функции `Boolean(value)`.

Правило преобразования:

- Значения, которые интуитивно "пустые", вроде `0`, пустой строки, `null`, `undefined` и `NaN`, становятся `false`.
- Все остальные значения становятся `true`.

Например:

```js run
alert(Boolean(1)) // true
alert(Boolean(0)) // false

alert(Boolean('Привет!')) // true
alert(Boolean('')) // false
```

````warn header="Заметим, что строчка с нулём `\"0\"`— это`true`" Некоторые языки (к примеру, PHP) воспринимают строку `"0"`как`false`. Но в JavaScript, если строка не пустая, то она всегда `true`.

```js run
alert(Boolean('0')) // true
alert(Boolean(' ')) // пробел это тоже true (любая непустая строка это true)
```

</p>
</details>
<br/>

## Итого

Существует 3 наиболее широко используемых преобразования: строковое, численное и логическое.

**`Строковое`** -- Происходит, когда нам нужно что-то вывести. Может быть вызвано с помощью `String(value)`. Для примитивных значений работает очевидным образом.

**`Численное`** -- Происходит в математических операциях. Может быть вызвано с помощью `Number(value)`.

Преобразование подчиняется правилам:

| Значение                            | Становится...                                                                                                                                                          |
| ----------------------------------- | ---------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| `undefined`                         | `NaN`                                                                                                                                                                  |
| `null`                              | `0`                                                                                                                                                                    |
| <code>true&nbsp;/&nbsp;false</code> | `1 / 0`                                                                                                                                                                |
| `string`                            | Пробельные символы по краям обрезаются. Далее, если остаётся пустая строка, то получаем `0`, иначе из непустой строки "считывается" число. При ошибке результат `NaN`. |

**`Логическое`** -- Происходит в логических операциях. Может быть вызвано с помощью `Boolean(value)`.

Подчиняется правилам:

| Значение                              | Становится... |
| ------------------------------------- | ------------- |
| `0`, `null`, `undefined`, `NaN`, `""` | `false`       |
| любое другое значение                 | `true`        |

Большую часть из этих правил легко понять и запомнить. Особые случаи, в которых часто допускаются ошибки:

- `undefined` при численном преобразовании становится `NaN`, не `0`.
- `"0"` и строки из одних пробелов типа `" "` при логическом преобразовании всегда `true`.

- В этой главе мы не говорили об объектах. Мы вернёмся к ним позже, в главе <info:object-toprimitive>, посвящённой только объектам, сразу после того, как узнаем больше про основы JavaScript.
  <br/>

# 2.8 Базовые операторы, математика

<details><summary><b>Ответ</b></summary>
<p>
Многие операторы знакомы нам ещё со школы: сложение `+`, умножение `*`, вычитание `-` и так далее.

В этой главе мы начнём с простых операторов, а потом сконцентрируемся на специфических для JavaScript аспектах, которые не проходят в школьном курсе арифметики.

## Термины: "унарный", "бинарный", "операнд"

Прежде, чем мы двинемся дальше, давайте разберёмся с терминологией.

- _Операнд_ -- то, к чему применяется оператор. Например, в умножении `5 * 2` есть два операнда: левый операнд равен `5`, а правый операнд равен `2`. Иногда их называют "аргументами" вместо "операндов".
- _Унарным_ называется оператор, который применяется к одному операнду. Например, оператор унарный минус `"-"` меняет знак числа на противоположный:

  ```js run
  let x = 1;

  *!*
  x = -x;
  */!*
  alert( x ); // -1, применили унарный минус
  ```

- _Бинарным_ называется оператор, который применяется к двум операндам. Тот же минус существует и в бинарной форме:

  ```js run no-beautify
  let x = 1,
  	y = 3
  alert(y - x) // 2, бинарный минус вычитает значения
  ```

  Формально, в последних примерах мы говорим о двух разных операторах, использующих один символ: оператор отрицания (унарный оператор, который обращает знак) и оператор вычитания (бинарный оператор, который вычитает одно число из другого).

## Математика

Поддерживаются следующие математические операторы:

- Сложение `+`,
- Вычитание `-`,
- Умножение `*`,
- Деление `/`,
- Взятие остатка от деления `%`,
- Возведение в степень `**`.

Первые четыре оператора очевидны, а про `%` и `**` стоит сказать несколько слов.

### Взятие остатка %

Оператор взятия остатка `%`, несмотря на обозначение, никакого отношения к процентам не имеет.

Результат `a % b` – это [остаток](https://ru.wikipedia.org/wiki/Деление_с_остатком) от целочисленного деления `a` на `b`.

Например:

```js run
alert(5 % 2) // 1, остаток от деления 5 на 2
alert(8 % 3) // 2, остаток от деления 8 на 3
```

### Возведение в степень \*\*

В выражении `a ** b` оператор возведения в степень умножает `a` на само себя `b` раз.

Например:

```js run
alert(2 ** 2) // 4  (2 умножено на себя 2 раза)
alert(2 ** 3) // 8  (2 * 2 * 2, 3 раза)
alert(2 ** 4) // 16 (2 * 2 * 2 * 2, 4 раза)
```

Математически, оператор работает и для нецелых чисел. Например, квадратный корень является возведением в степень `1/2`:

```js run
alert(4 ** (1 / 2)) // 2 (степень 1/2 эквивалентна взятию квадратного корня)
alert(8 ** (1 / 3)) // 2 (степень 1/3 эквивалентна взятию кубического корня)
```

## Сложение строк при помощи бинарного +

Давайте рассмотрим специальные возможности операторов JavaScript, которые выходят за рамки школьной арифметики.

Обычно при помощи плюса `'+'` складывают числа.

Но если бинарный оператор `'+'` применить к строкам, то он их объединяет в одну:

```js
let s = 'моя' + 'строка'
alert(s) // моястрока
```

Обратите внимание, если хотя бы один операнд является строкой, то второй будет также преобразован в строку.

Например:

```js run
alert('1' + 2) // "12"
alert(2 + '1') // "21"
```

Как видите, не важно, первый или второй операнд является строкой.

Вот пример посложнее:

```js run
alert(2 + 2 + '1') // будет "41", а не "221"
```

Здесь операторы работают один за другим. Первый `+` складывает два числа и возвращает `4`, затем следующий `+` объединяет результат со строкой, производя действие `4 + '1' = '41'`.

Сложение и преобразование строк — это особенность бинарного плюса `+`. Другие арифметические операторы работают только с числами и всегда преобразуют операнды в числа.

Например, вычитание и деление:

```js run
alert(6 - '2') // 4, '2' приводится к числу
alert('6' / '2') // 3, оба операнда приводятся к числам
```

## Приведение к числу, унарный +

Плюс `+` существует в двух формах: бинарной, которую мы использовали выше, и унарной.

Унарный, то есть применённый к одному значению, плюс `+` ничего не делает с числами. Но если операнд не число, унарный плюс преобразует его в число.

Например:

```js run
// Не влияет на числа
let x = 1;
alert( +x ); // 1

let y = -2;
alert( +y ); // -2

*!*
// Преобразует не числа в числа
alert( +true ); // 1
alert( +"" );   // 0
*/!*
```

На самом деле это то же самое, что и `Number(...)`, только короче.

Необходимость преобразовывать строки в числа возникает очень часто. Например, обычно значения полей HTML-формы — это строки. А что, если их нужно, к примеру, сложить?

Бинарный плюс сложит их как строки:

```js run
let apples = '2'
let oranges = '3'

alert(apples + oranges) // "23", так как бинарный плюс объединяет строки
```

Поэтому используем унарный плюс, чтобы преобразовать к числу:

```js run
let apples = "2";
let oranges = "3";

*!*
// оба операнда предварительно преобразованы в числа
alert( +apples + +oranges ); // 5
*/!*

// более длинный вариант
// alert( Number(apples) + Number(oranges) ); // 5
```

С точки зрения математика, такое изобилие плюсов выглядит странным. Но с точки зрения программиста тут нет ничего особенного: сначала выполнятся унарные плюсы, которые приведут строки к числам, а затем бинарный `'+'` их сложит.

Почему унарные плюсы выполнились до бинарного сложения? Как мы сейчас увидим, дело в их приоритете.

## Приоритет операторов

В том случае, если в выражении есть несколько операторов – порядок их выполнения определяется _приоритетом_, или, другими словами, существует определённый порядок выполнения операторов.

Из школы мы знаем, что умножение в выражении `1 + 2 * 2` выполнится раньше сложения. Это как раз и есть "приоритет". Говорят, что умножение имеет более высокий приоритет, чем сложение.

Скобки важнее, чем приоритет, так что, если мы не удовлетворены порядком по умолчанию, мы можем использовать их, чтобы изменить приоритет. Например, написать `(1 + 2) * 2`.

В JavaScript много операторов. Каждый оператор имеет соответствующий номер приоритета. Тот, у кого это число больше, – выполнится раньше. Если приоритет одинаковый, то порядок выполнения – слева направо.

Отрывок из [таблицы приоритетов](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Operators/Operator_Precedence) (нет необходимости всё запоминать, обратите внимание, что приоритет унарных операторов выше, чем соответствующих бинарных):

| Приоритет | Название             | Обозначение |
| --------- | -------------------- | ----------- |
| ...       | ...                  | ...         |
| 15        | унарный плюс         | `+`         |
| 15        | унарный минус        | `-`         |
| 14        | возведение в степень | `**`        |
| 13        | умножение            | `*`         |
| 13        | деление              | `/`         |
| 12        | сложение             | `+`         |
| 12        | вычитание            | `-`         |
| ...       | ...                  | ...         |
| 2         | присваивание         | `=`         |
| ...       | ...                  | ...         |

Так как "унарный плюс" имеет приоритет `15`, который выше, чем `12` у "сложения" (бинарный плюс), то в выражении `"+apples + +oranges"` сначала выполнятся унарные плюсы, а затем сложение.

## Присваивание

Давайте отметим, что в таблице приоритетов также есть оператор присваивания `=`. У него один из самых низких приоритетов: `2`.

Именно поэтому, когда переменной что-либо присваивают, например, `x = 2 * 2 + 1`, то сначала выполнится арифметика, а уже затем произойдёт присваивание `=` с сохранением результата в `x`.

```js
let x = 2 * 2 + 1

alert(x) // 5
```

### Присваивание = возвращает значение

Тот факт, что `=` является оператором, а не "магической" конструкцией языка, имеет интересные последствия.

Большинство операторов в JavaScript возвращают значение. Для некоторых это очевидно, например сложение `+` или умножение `*`. Но и оператор присваивания не является исключением.

Вызов `x = value` записывает `value` в `x` _и возвращает его_.

Благодаря этому присваивание можно использовать как часть более сложного выражения:

```js run
let a = 1;
let b = 2;

*!*
let c = 3 - (a = b + 1);
*/!*

alert( a ); // 3
alert( c ); // 0
```

В примере выше результатом `(a = b + 1)` будет значение, которое присваивается переменной `a` (то есть `3`). Потом оно используется для дальнейших вычислений.

Забавное применение присваивания, не так ли? Нам нужно понимать, как это работает, потому что иногда это можно увидеть в JavaScript-библиотеках.

Однако писать самим в таком стиле не рекомендуется. Такие трюки не сделают ваш код более понятным или читабельным.

### Присваивание по цепочке

Рассмотрим ещё одну интересную возможность: цепочку присваиваний.

```js run
let a, b, c;

*!*
a = b = c = 2 + 2;
*/!*

alert( a ); // 4
alert( b ); // 4
alert( c ); // 4
```

Такое присваивание работает справа налево. Сначала вычисляется самое правое выражение `2 + 2`, и затем результат присваивается переменным слева: `c`, `b` и `a`. В конце у всех переменных будет одно значение.

Опять-таки, чтобы код читался легче, лучше разделять подобные конструкции на несколько строчек:

```js
c = 2 + 2
b = c
a = c
```

Польза от такого стиля особенно ощущается при быстром просмотре кода.

## Сокращённая арифметика с присваиванием

Часто нужно применить оператор к переменной и сохранить результат в ней же.

Например:

```js
let n = 2
n = n + 5
n = n * 2
```

Эту запись можно укоротить при помощи совмещённых операторов `+=` и `*=`:

```js run
let n = 2
n += 5 // теперь n = 7 (работает как n = n + 5)
n *= 2 // теперь n = 14 (работает как n = n * 2)

alert(n) // 14
```

Подобные краткие формы записи существуют для всех арифметических и побитовых операторов: `/=`, `-=` и так далее.

Вызов с присваиванием имеет в точности такой же приоритет, как обычное присваивание, то есть выполнится после большинства других операций:

```js run
let n = 2

n *= 3 + 5

alert(n) // 16  (сначала выполнится правая часть, выражение идентично n *= 8)
```

## Инкремент/декремент

<!-- Не получается использовать -- в заголовке, так как парсер превращает -- в длинное тире – -->

Одной из наиболее частых числовых операций является увеличение или уменьшение на единицу.

Для этого существуют даже специальные операторы:

- **Инкремент** `++` увеличивает переменную на 1:

  ```js run no-beautify
  let counter = 2
  counter++ // работает как counter = counter + 1, просто запись короче
  alert(counter) // 3
  ```

- **Декремент** `--` уменьшает переменную на 1:

  ```js run no-beautify
  let counter = 2
  counter-- // работает как counter = counter - 1, просто запись короче
  alert(counter) // 1
  ```

```warn
Инкремент/декремент можно применить только к переменной. Попытка использовать его на значении, типа 5++, приведёт к ошибке.
```

Операторы `++` и `--` могут быть расположены не только после, но и до переменной.

- Когда оператор идёт после переменной — это "постфиксная форма": `counter++`.
- "Префиксная форма" — это когда оператор идёт перед переменной: `++counter`.

Обе эти инструкции делают одно и то же: увеличивают `counter` на `1`.

Есть ли разница между ними? Да, но увидеть её мы сможем, только если будем использовать значение, которое возвращают `++/--`.

Давайте проясним этот момент. Как мы знаем, все операторы возвращают значение. Операторы инкремента/декремента не исключение. Префиксная форма возвращает новое значение, в то время как постфиксная форма возвращает старое (до увеличения/уменьшения числа).

Чтобы увидеть разницу, вот небольшой пример:

```js run
let counter = 1
let a = ++counter // (*)

alert(a) // *!*2*/!*
```

В строке `(*)` _префиксная_ форма `++counter` увеличивает `counter` и возвращает новое значение `2`. Так что `alert` покажет `2`.

Теперь посмотрим на постфиксную форму:

```js run
let counter = 1
let a = counter++ // (*) меняем ++counter на counter++

alert(a) // *!*1*/!*
```

В строке `(*)` _постфиксная_ форма `counter++` также увеличивает `counter`, но возвращает _старое_ значение (которое было до увеличения). Так что `alert` покажет `1`.

## Побитовые операторы

Побитовые операторы работают с 32-разрядными целыми числами (при необходимости приводят к ним), на уровне их внутреннего двоичного представления.

Эти операторы не являются чем-то специфичным для JavaScript, они поддерживаются в большинстве языков программирования.

Поддерживаются следующие побитовые операторы:

- AND(и) ( `&` )
- OR(или) ( `|` )
- XOR(побитовое исключающее или) ( `^` )
- NOT(не) ( `~` )
- LEFT SHIFT(левый сдвиг) ( `<<` )
- RIGHT SHIFT(правый сдвиг) ( `>>` )
- ZERO-FILL RIGHT SHIFT(правый сдвиг с заполнением нулями) ( `>>>` )

Они используются редко, когда возникает необходимость оперировать с числами на очень низком (побитовом) уровне. В ближайшем времени они нам не понадобятся, так как веб-разработчики редко к ним прибегают, хотя в некоторых сферах (например, в криптографии) они полезны. Можете прочитать [раздел о них](https://developer.mozilla.org/ru/docs/Web/JavaScript/Guide/Expressions_and_Operators#Битовые_поразрядные_операторы) на MDN, когда возникнет реальная необходимость.

## Оператор "запятая"

Оператор "запятая" (`,`) редко применяется и является одним из самых необычных. Иногда он используется для написания более короткого кода, поэтому нам нужно знать его, чтобы понимать, что при этом происходит.

Оператор "запятая" предоставляет нам возможность вычислять несколько выражений, разделяя их запятой `,`. Каждое выражение выполняется, но возвращается результат только последнего.

Например:

```js run
*!*
let a = (1 + 2, 3 + 4);
*/!*
alert( a ); // 7 (результат вычисления 3 + 4)

```

Первое выражение `1 + 2` выполняется, а результат отбрасывается. Затем идёт `3 + 4`, выражение выполняется и возвращается результат.

```
Пожалуйста, обратите внимание, что оператор `,` имеет очень низкий приоритет, ниже `=`, поэтому скобки важны в приведённом выше примере.

Без них в `a = 1 + 2, 3 + 4` сначала выполнится `+`, суммируя числа в `a = 3, 7`, затем оператор присваивания `=` присвоит `a = 3`, а то, что идёт дальше, будет игнорировано. Всё так же, как в `(a = 1 + 2), 3 + 4`.
```

Зачем нам оператор, который отбрасывает всё, кроме последнего выражения?

Иногда его используют в составе более сложных конструкций, чтобы сделать несколько действий в одной строке.

Например:

```js
// три операции в одной строке
for (*!*a = 1, b = 3, c = a * b*/!*; a < 10; a++) {
 ...
}
```

Такие трюки используются во многих JavaScript-фреймворках. Вот почему мы упоминаем их. Но обычно они не улучшают читабельность кода, поэтому стоит хорошо подумать, прежде чем их использовать.

</p>
</details>
<br/>
Подведём итоги:

- Если результат оператора не используется, а нужно только увеличить/уменьшить переменную, тогда без разницы, какую форму использовать:

  ```js run
  let counter = 0
  counter++
  ++counter
  alert(counter) // 2, обе строки сделали одно и то же
  ```

- Если хочется тут же использовать результат, то нужна префиксная форма:

  ```js run
  let counter = 0
  alert(++counter) // 1
  ```

- Если нужно увеличить и при этом получить значение переменной _до увеличения_ нужна постфиксная форма:

```js run
let counter = 0
alert(counter++) // 0
```

"Инкремент/декремент можно использовать в любых выражениях"
Операторы `++/--` могут также использоваться внутри выражений. Их приоритет выше, чем у большинства других арифметических операций.

Например:

```js run
let counter = 1
alert(2 * ++counter) // 4
```

Сравните с:

```js run
let counter = 1
alert(2 * counter++) // 2, потому что counter++ возвращает "старое" значение
```

Хотя технически здесь всё в порядке, такая запись обычно делает код менее читабельным. Одна строка выполняет множество действий -- нехорошо.

При беглом чтении кода можно с лёгкостью пропустить такой `counter++`, и будет неочевидно, что переменная увеличивается.

Лучше использовать стиль "одна строка -- одно действие":

```js run
let counter = 1
alert(2 * counter)
counter++
```

<br/>

# 2.9 Операторы сравнения

<details><summary><b>Ответ</b></summary>
<p>
В JavaScript они записываются так:

- Больше/меньше: <code>a &gt; b</code>, <code>a &lt; b</code>.
- Больше/меньше или равно: <code>a &gt;= b</code>, <code>a &lt;= b</code>.
- Равно: `a == b`. Обратите внимание, для сравнения используется двойной знак равенства `==`. Один знак равенства `a = b` означал бы присваивание.
- Не равно. В математике обозначается символом <code>&ne;</code>, но в JavaScript записывается как <code>a != b</code>.

В этом разделе мы больше узнаем про то, какие бывают сравнения, как язык с ними работает и к каким неожиданностям мы должны быть готовы.

В конце вы найдёте хороший рецепт того, как избегать "причуд" сравнения в JavaScript.

## Результат сравнения имеет логический тип

Все операторы сравнения возвращают значение логического типа:

- `true` -- означает "да", "верно", "истина".
- `false` -- означает "нет", "неверно", "ложь".

Например:

```js run
alert(2 > 1) // true (верно)
alert(2 == 1) // false (неверно)
alert(2 != 1) // true (верно)
```

Результат сравнения можно присвоить переменной, как и любое значение:

```js run
let result = 5 > 4 // результат сравнения присваивается переменной result
alert(result) // true
```

## Сравнение строк

Чтобы определить, что одна строка больше другой, JavaScript использует "алфавитный" или "лексикографический" порядок.

Другими словами, строки сравниваются посимвольно.

Например:

```js run
alert('Я' > 'А') // true
alert('Коты' > 'Кода') // true
alert('Сонный' > 'Сон') // true
```

Алгоритм сравнения двух строк довольно прост:

1. Сначала сравниваются первые символы строк.
2. Если первый символ первой строки больше (меньше), чем первый символ второй, то первая строка больше (меньше) второй. Сравнение завершено.
3. Если первые символы равны, то таким же образом сравниваются уже вторые символы строк.
4. Сравнение продолжается, пока не закончится одна из строк.
5. Если обе строки заканчиваются одновременно, то они равны. Иначе, большей считается более длинная строка.

В примерах выше сравнение `'Я' > 'А'` завершится на первом шаге, тогда как строки `'Коты'` и `'Кода'` будут сравниваться посимвольно:

1. `К` равна `К`.
2. `о` равна `о`.
3. `т` больше, чем `д`. На этом сравнение заканчивается. Первая строка больше.

```smart header="Используется кодировка Unicode, а не настоящий алфавит"
Приведённый выше алгоритм сравнения похож на алгоритм, используемый в словарях и телефонных книгах, но между ними есть и различия.

Например, в JavaScript имеет значение регистр символов. Заглавная буква `"A"` не равна строчной `"a"`. Какая же из них больше? Строчная `"a"`. Почему? Потому что строчные буквы имеют больший код во внутренней таблице кодирования, которую использует JavaScript (Unicode). Мы ещё поговорим о внутреннем представлении строк и его влиянии в главе <info:string>.
```

## Сравнение разных типов

При сравнении значений разных типов JavaScript приводит каждое из них к числу.

Например:

```js run
alert('2' > 1) // true, строка '2' становится числом 2
alert('01' == 1) // true, строка '01' становится числом 1
```

Логическое значение `true` становится `1`, а `false` – `0`.

Например:

```js run
alert(true == 1) // true
alert(false == 0) // true
```

````smart header="Забавное следствие"
Возможна следующая ситуация:

- Два значения равны.
- Одно из них `true` как логическое значение, другое – `false`.

Например:

```js run
let a = 0;
alert( Boolean(a) ); // false

let b = "0";
alert( Boolean(b) ); // true

alert(a == b); // true!
```

С точки зрения JavaScript, результат ожидаем. Равенство преобразует значения, используя числовое преобразование, поэтому `"0"` становится `0`. В то время как явное преобразование с помощью `Boolean` использует другой набор правил.
````

## Строгое сравнение

Использование обычного сравнения `==` может вызывать проблемы. Например, оно не отличает `0` от `false`:

```js run
alert(0 == false) // true
```

Та же проблема с пустой строкой:

```js run
alert('' == false) // true
```

Это происходит из-за того, что операнды разных типов преобразуются оператором `==` к числу. В итоге, и пустая строка, и `false` становятся нулём.

Как же тогда отличать `0` от `false`?

**Оператор строгого равенства `===` проверяет равенство без приведения типов.**

Другими словами, если `a` и `b` имеют разные типы, то проверка `a === b` немедленно возвращает `false` без попытки их преобразования.

Давайте проверим:

```js run
alert(0 === false) // false, так как сравниваются разные типы
```

Ещё есть оператор строгого неравенства `!==`, аналогичный `!=`.

Оператор строгого равенства дольше писать, но он делает код более очевидным и оставляет меньше места для ошибок.

## Сравнение с null и undefined

Поведение `null` и `undefined` при сравнении с другими значениями — особое:

При строгом равенстве `===`
: Эти значения различны, так как различны их типы.

    ```js run
    alert( null === undefined ); // false
    ```

При нестрогом равенстве `==`
: Эти значения равны друг другу и не равны никаким другим значениям. Это специальное правило языка.

    ```js run
    alert( null == undefined ); // true
    ```

При использовании математических операторов и других операторов сравнения `< > <= >=`
: Значения `null/undefined` преобразуются к числам: `null` становится `0`, а `undefined` – `NaN`.

Посмотрим, какие забавные вещи случаются, когда мы применяем эти правила. И, что более важно, как избежать ошибок при их использовании.

### Странный результат сравнения null и 0

Сравним `null` с нулём:

```js run
alert(null > 0) // (1) false
alert(null == 0) // (2) false
alert(null >= 0) // (3) *!*true*/!*
```

С точки зрения математики это странно. Результат последнего сравнения говорит о том, что "`null` больше или равно нулю", тогда результат одного из сравнений выше должен быть `true`, но они оба ложны.

Причина в том, что нестрогое равенство и сравнения `> < >= <=` работают по-разному. Сравнения преобразуют `null` в число, рассматривая его как `0`. Поэтому выражение (3) `null >= 0` истинно, а `null > 0` ложно.

С другой стороны, для нестрогого равенства `==` значений `undefined` и `null` действует особое правило: эти значения ни к чему не приводятся, они равны друг другу и не равны ничему другому. Поэтому (2) `null == 0` ложно.

### Несравненное значение undefined

Значение `undefined` несравнимо с другими значениями:

```js run
alert(undefined > 0) // false (1)
alert(undefined < 0) // false (2)
alert(undefined == 0) // false (3)
```

Почему же сравнение `undefined` с нулём всегда ложно?

На это есть следующие причины:

- Сравнения `(1)` и `(2)` возвращают `false`, потому что `undefined` преобразуется в `NaN`, а `NaN` – это специальное числовое значение, которое возвращает `false` при любых сравнениях.
- Нестрогое равенство `(3)` возвращает `false`, потому что `undefined` равно только `null`, `undefined` и ничему больше.

### Как избежать проблем

Зачем мы рассмотрели все эти примеры? Должны ли мы постоянно помнить обо всех этих особенностях? Не обязательно. Со временем все они станут вам знакомы, но можно избежать проблем, если следовать надёжным правилам:

- Относитесь очень осторожно к любому сравнению с `undefined/null`, кроме случаев строгого равенства `===`.
- Не используйте сравнения `>= > < <=` с переменными, которые могут принимать значения `null/undefined`, разве что вы полностью уверены в том, что делаете. Если переменная может принимать эти значения, то добавьте для них отдельные проверки.
</p>
</details>

## Итого

- Операторы сравнения возвращают значения логического типа.
- Строки сравниваются посимвольно в лексикографическом порядке.
- Значения разных типов при сравнении приводятся к числу. Исключением является сравнение с помощью операторов строгого равенства/неравенства.
- Значения `null` и `undefined` равны `==` друг другу и не равны любому другому значению.
- Будьте осторожны при использовании операторов сравнений вроде `>` и `<` с переменными, которые могут принимать значения `null/undefined`. Хорошей идеей будет сделать отдельную проверку на `null/undefined`.

<br/>

<br/>

# 2.10 Условное ветвление: if, '?'

<details><summary><b>Ответ</b></summary>
<p>

# Условное ветвление: if, '?'

Иногда нам нужно выполнить различные действия в зависимости от условий.

Для этого мы можем использовать инструкцию `if` и условный оператор `?`, который также называют оператором "вопросительный знак".

## Инструкция "if"

Инструкция `if(...)` вычисляет условие в скобках и, если результат `true`, то выполняет блок кода.

Например:

```js run
let year = prompt('В каком году была опубликована спецификация ECMAScript-2015?', '');

*!*
if (year == 2015) alert( 'Вы правы!' );
*/!*
```

В примере выше, условие -- это простая проверка на равенство (`year == 2015`), но оно может быть и гораздо более сложным.

Если мы хотим выполнить более одной инструкции, то нужно заключить блок кода в фигурные скобки:

```js
if (year == 2015) {
	alert('Правильно!')
	alert('Вы такой умный!')
}
```

Мы рекомендуем использовать фигурные скобки `{}` всегда, когда вы используете инструкцию `if`, даже если выполняется только одна команда. Это улучшает читаемость кода.

## Преобразование к логическому типу

Инструкция `if (…)` вычисляет выражение в скобках и преобразует результат к логическому типу.

Давайте вспомним правила преобразования типов из главы <info:type-conversions>:

- Число `0`, пустая строка `""`, `null`, `undefined` и `NaN` становятся `false`. Из-за этого их называют "ложными" ("falsy") значениями.
- Остальные значения становятся `true`, поэтому их называют "правдивыми" ("truthy").

Таким образом, код при таком условии никогда не выполнится:

```js
if (0) { // 0 is falsy
  ...
}
```

...а при таком -- выполнится всегда:

```js
if (1) { // 1 is truthy
  ...
}
```

Мы также можем передать заранее вычисленное в переменной логическое значение в `if`, например так:

```js
let condition = (year == 2015); // преобразуется к true или false

if (condition) {
  ...
}
```

## Блок "else"

Инструкция `if` может содержать необязательный блок "else" ("иначе"). Он выполняется, когда условие ложно.

Например:

```js run
let year = prompt(
	'В каком году была опубликована спецификация ECMAScript-2015?',
	''
)

if (year == 2015) {
	alert('Да вы знаток!')
} else {
	alert('А вот и неправильно!') // любое значение, кроме 2015
}
```

## Несколько условий: "else if"

Иногда, нужно проверить несколько вариантов условия. Для этого используется блок `else if`.

Например:

```js run
let year = prompt(
	'В каком году была опубликована спецификация ECMAScript-2015?',
	''
)

if (year < 2015) {
	alert('Это слишком рано...')
} else if (year > 2015) {
	alert('Это поздновато')
} else {
	alert('Верно!')
}
```

В приведённом выше коде JavaScript сначала проверит `year < 2015`. Если это неверно, он переходит к следующему условию `year > 2015`. Если оно тоже ложно, тогда сработает последний `alert`.

Блоков `else if` может быть и больше. Присутствие блока `else` не является обязательным.

## Условный оператор '?'

Иногда нам нужно определить переменную в зависимости от условия.

Например:

```js run no-beautify
let accessAllowed;
let age = prompt('Сколько вам лет?', '');

*!*
if (age > 18) {
  accessAllowed = true;
} else {
  accessAllowed = false;
}
*/!*

alert(accessAllowed);
```

Так называемый "условный" оператор "вопросительный знак" позволяет нам сделать это более коротким и простым способом.

Оператор представлен знаком вопроса `?`. Его также называют "тернарный", так как этот оператор, единственный в своём роде, имеет три аргумента.

Синтаксис:

```js
let result = условие ? значение1 : значение2
```

Сначала вычисляется `условие`: если оно истинно, тогда возвращается `значение1`, в противном случае -- `значение2`.

Например:

```js
let accessAllowed = age > 18 ? true : false
```

Технически, мы можем опустить круглые скобки вокруг `age > 18`. Оператор вопросительного знака имеет низкий приоритет, поэтому он выполняется после сравнения `>`.

Этот пример будет делать то же самое, что и предыдущий:

```js
// оператор сравнения "age > 18" выполняется первым в любом случае
// (нет необходимости заключать его в скобки)
let accessAllowed = age > 18 ? true : false
```

Но скобки делают код более простым для восприятия, поэтому мы рекомендуем их использовать.

````smart
В примере выше вы можете избежать использования оператора вопросительного знака `?`, т.к. сравнение само по себе уже возвращает `true/false`:

```js
// то же самое
let accessAllowed = age > 18;
```
````

## Несколько операторов '?'

Последовательность операторов вопросительного знака `?` позволяет вернуть значение, которое зависит от более чем одного условия.

Например:

```js run
let age = prompt('Возраст?', 18)

let message =
	age < 3
		? 'Здравствуй, малыш!'
		: age < 18
		? 'Привет!'
		: age < 100
		? 'Здравствуйте!'
		: 'Какой необычный возраст!'

alert(message)
```

Поначалу может быть сложно понять, что происходит. Но при ближайшем рассмотрении мы видим, что это обычная последовательная проверка:

1. Первый знак вопроса проверяет `age < 3`.
2. Если верно -- возвращает `'Здравствуй, малыш!'`. В противном случае, проверяет выражение после двоеточия ':', вычисляет `age < 18`.
3. Если это верно -- возвращает `'Привет!'`. В противном случае, проверяет выражение после следующего двоеточия ':', вычисляет `age < 100`.
4. Если это верно -- возвращает `'Здравствуйте!'`. В противном случае, возвращает выражение после последнего двоеточия -- `'Какой необычный возраст!'`.

Вот как это выглядит при использовании `if..else`:

```js
if (age < 3) {
	message = 'Здравствуй, малыш!'
} else if (age < 18) {
	message = 'Привет!'
} else if (age < 100) {
	message = 'Здравствуйте!'
} else {
	message = 'Какой необычный возраст!'
}
```

## Нетрадиционное использование '?'

Иногда оператор "вопросительный знак" `?` используется в качестве замены `if`:

```js run no-beautify
let company = prompt('Какая компания создала JavaScript?', '');

*!*
(company == 'Netscape') ?
   alert('Верно!') : alert('Неправильно.');
*/!*
```

В зависимости от условия `company == 'Netscape'`, будет выполнена либо первая, либо вторая часть после `?`.

Здесь мы не присваиваем результат переменной. Вместо этого мы выполняем различный код в зависимости от условия.

**Не рекомендуется использовать оператор вопросительного знака таким образом.**

Несмотря на то, что такая запись короче, чем эквивалентная инструкция `if`, она хуже читается.

Вот, для сравнения, тот же код, использующий `if`:

```js run no-beautify
let company = prompt('Какая компания создала JavaScript?', '');

*!*
if (company == 'Netscape') {
  alert('Верно!');
} else {
  alert('Неправильно.');
}
*/!*
```

При чтении глаза сканируют код по вертикали. Блоки кода, занимающие несколько строк, воспринимаются гораздо легче, чем длинный горизонтальный набор инструкций.

Смысл оператора "вопросительный знак" `?` -- вернуть то или иное значение, в зависимости от условия. Пожалуйста, используйте его именно для этого. Когда вам нужно выполнить разные ветви кода -- используйте `if`.

</p>
</details>
<br/>

<br/>

# 2.11 Логические операторы

<details><summary><b>Ответ</b></summary>
<p>
В JavaScript есть четыре логических оператора: `||` (ИЛИ), `&&` (И) и `!` (НЕ), `??` (Оператор нулевого слияния). Здесь мы рассмотрим первые три, оператор `??` будет в следующей статье.

Несмотря на своё название, данные операторы могут применяться к значениям любых типов. Полученные результаты также могут иметь различный тип.

Давайте рассмотрим их подробнее.

## || (ИЛИ)

Оператор "ИЛИ" выглядит как двойной символ вертикальной черты:

```js
result = a || b
```

Традиционно в программировании ИЛИ предназначено только для манипулирования булевыми значениями: в случае, если какой-либо из аргументов `true`, он вернёт `true`, в противоположной ситуации возвращается `false`.

В JavaScript, как мы увидим далее, этот оператор работает несколько иным образом. Но давайте сперва посмотрим, что происходит с булевыми значениями.

Существует всего четыре возможные логические комбинации:

```js run
alert(true || true) // true
alert(false || true) // true
alert(true || false) // true
alert(false || false) // false
```

Как мы можем наблюдать, результат операций всегда равен `true`, за исключением случая, когда оба аргумента `false`.

Если значение не логического типа, то оно к нему приводится в целях вычислений.

Например, число `1` будет воспринято как `true`, а `0` – как `false`:

```js run
if (1 || 0) {
	// работает как if( true || false )
	alert('truthy!')
}
```

Обычно оператор `||` используется в `if` для проверки истинности любого из заданных условий.

К примеру:

```js run
let hour = 9;

*!*
if (hour < 10 || hour > 18) {
*/!*
  alert( 'Офис закрыт.' );
}
```

Можно передать и больше условий:

```js run
let hour = 12
let isWeekend = true

if (hour < 10 || hour > 18 || isWeekend) {
	alert('Офис закрыт.') // это выходной
}
```

## ИЛИ "||" находит первое истинное значение

Описанная выше логика соответствует традиционной. Теперь давайте поработаем с "дополнительными" возможностями JavaScript.

Расширенный алгоритм работает следующим образом.

При выполнении ИЛИ `||` с несколькими значениями:

```js
result = value1 || value2 || value3
```

Оператор `||` выполняет следующие действия:

- Вычисляет операнды слева направо.
- Каждый операнд конвертирует в логическое значение. Если результат `true`, останавливается и возвращает исходное значение этого операнда.
- Если все операнды являются ложными (`false`), возвращает последний из них.

Значение возвращается в исходном виде, без преобразования.

Другими словами, цепочка ИЛИ `||` возвращает первое истинное значение или последнее, если такое значение не найдено.

Например:

```js run
alert(1 || 0) // 1
alert(true || 'no matter what') // true

alert(null || 1) // 1 (первое истинное значение)
alert(null || 0 || 1) // 1 (первое истинное значение)
alert(undefined || null || 0) // 0 (поскольку все ложно, возвращается последнее значение)
```

Это делает возможным более интересное применение оператора по сравнению с "чистым, традиционным, только булевым ИЛИ".

1. **Получение первого истинного значения из списка переменных или выражений.**

   Представим, что у нас имеется ряд переменных, которые могут содержать данные или быть `null/undefined`. Как мы можем найти первую переменную с данными?

   С помощью `||`:

   ```js run
   let currentUser = null;
   let defaultUser = "John";

   *!*
   let name = currentUser || defaultUser || "unnamed";
   */!*

   alert( name ); // выбирается "John" – первое истинное значение
   ```

   Если бы и `currentUser`, и `defaultUser` были ложными, в качестве результата мы бы наблюдали `"unnamed"`.

2. **Сокращённое вычисление.**

   Операндами могут быть как отдельные значения, так и произвольные выражения. ИЛИ `||` вычисляет их слева направо. Вычисление останавливается при достижении первого истинного значения. Этот процесс называется "сокращённым вычислением", поскольку второй операнд вычисляется только в том случае, если первого недостаточно для вычисления всего выражения.

   Это хорошо заметно, когда выражение, указанное в качестве второго аргумента, имеет побочный эффект, например, изменение переменной.

   В приведённом ниже примере `x` не изменяется:

   ```js run no-beautify
   let x;

   *!*true*/!* || (x = 1);

   alert(x); // undefined, потому что (x = 1) не вычисляется
   ```

   Если бы первый аргумент имел значение `false`, то `||` приступил бы к вычислению второго и выполнил операцию присваивания:

   ```js run no-beautify
   let x;

   *!*false*/!* || (x = 1);

   alert(x); // 1
   ```

   Присваивание - лишь один пример. Конечно, могут быть и другие побочные эффекты, которые не проявятся, если вычисление до них не дойдёт.

   Как мы видим, этот вариант использования `||` является "аналогом `if`". Первый операнд преобразуется в логический. Если он оказывается ложным, начинается вычисление второго.

   В большинстве случаев лучше использовать "обычный" `if`, чтобы облегчить понимание кода, но иногда это может быть удобно.

## && (И)

Оператор И пишется как два амперсанда `&&`:

```js
result = a && b
```

В традиционном программировании И возвращает `true`, если оба аргумента истинны, а иначе – `false`:

```js run
alert(true && true) // true
alert(false && true) // false
alert(true && false) // false
alert(false && false) // false
```

Пример с `if`:

```js run
let hour = 12
let minute = 30

if (hour == 12 && minute == 30) {
	alert('The time is 12:30')
}
```

Как и в случае с ИЛИ, любое значение допускается в качестве операнда И:

```js run
if (1 && 0) {
	// вычисляется как true && false
	alert('не сработает, так как результат ложный')
}
```

## И "&&" находит первое ложное значение

При нескольких подряд операторах И:

```js
result = value1 && value2 && value3
```

Оператор `&&` выполняет следующие действия:

- Вычисляет операнды слева направо.
- Каждый операнд преобразует в логическое значение. Если результат `false`, останавливается и возвращает исходное значение этого операнда.
- Если все операнды были истинными, возвращается последний.

Другими словами, И возвращает первое ложное значение. Или последнее, если ничего не найдено.

Вышеуказанные правила схожи с поведением ИЛИ. Разница в том, что И возвращает первое _ложное_ значение, а ИЛИ -  первое _истинное_.

Примеры:

```js run
// Если первый операнд истинный,
// И возвращает второй:
alert(1 && 0) // 0
alert(1 && 5) // 5

// Если первый операнд ложный,
// И возвращает его. Второй операнд игнорируется
alert(null && 5) // null
alert(0 && 'no matter what') // 0
```

Можно передать несколько значений подряд. В таком случае возвратится первое "ложное" значение, на котором остановились вычисления.

```js run
alert(1 && 2 && null && 3) // null
```

Когда все значения верны, возвращается последнее

```js run
alert(1 && 2 && 3) // 3
```

````
smart header="Приоритет оператора `&&`больше, чем у`||`" Приоритет оператора И `&&`больше, чем ИЛИ`||`, так что он выполняется раньше.
Таким образом, код `a && b || c && d` по существу такой же, как если бы выражения `&&` были в круглых скобках: `(a && b) || (c && d)`.
````

Как и оператор ИЛИ `||`, И `&&` иногда может заменять `if`.

К примеру:

```js run
let x = 1;

(x > 0) && alert( 'Greater than zero!' );
```

Действие в правой части `&&` выполнится только в том случае, если до него дойдут вычисления. То есть, `alert` сработает, если в левой части (`x > 0)` будет `true`.


Получился аналог:

```js run
let x = 1;

if (x > 0) {
  alert( 'Greater than zero!' );
}
```

Однако, как правило, вариант с `if` лучше читается и воспринимается.

Он более очевиден, поэтому лучше использовать его.

## ! (НЕ)

Оператор НЕ представлен восклицательным знаком `!`.

Синтаксис довольно прост:

```js
result = !value;
```

Оператор принимает один аргумент и выполняет следующие действия:

1. Сначала приводит аргумент к логическому типу `true/false`.
2. Затем возвращает противоположное значение.

Например:

```js run
alert( !true ); // false
alert( !0 ); // true
```

В частности, двойное НЕ `!!` используют для преобразования значений к логическому типу:

```js run
alert( !!"non-empty string" ); // true
alert( !!null ); // false
```

</p>
</details>
<br/>

<br/>

# 2.12 Оператор нулевого слияния (??)

<details><summary><b>Ответ</b></summary>
<p>

Оператор нулевого слияния представляет собой два вопросительных знака `??`.

Так как он обрабатывает `null` и `undefined` одинаковым образом, то для этой статьи мы введём специальный термин. Для краткости будем говорить, что значение "определено",  если оно не равняется ни `null`, ни `undefined`.

Результат выражения `a ?? b` будет следующим:
- если `a` определено, то `a`,
- если `a` не определено, то `b`.

Иначе говоря, оператор `??` возвращает первый аргумент, если он не `null/undefined`, иначе второй.

Оператор нулевого слияния не является чем-то принципиально новым. Это всего лишь удобный синтаксис, как из двух значений получить одно, которое "определено".

Вот как можно переписать выражение `result = a ?? b`, используя уже знакомые нам операторы:

```js
result = (a !== null && a !== undefined) ? a : b;
```

Теперь должно быть абсолютно ясно, что делает `??`. Давайте посмотрим, где это может быть полезно.

Как правило, оператор `??` нужен для того, чтобы задать значение по умолчанию для потенциально неопределённой переменной.

Например, здесь мы отобразим `user`, если её значение не `null/undefined`, в противном случае `Аноним`:

```js run
let user;

alert(user ?? "Аноним"); // Аноним (user не существует)
```

А вот пример, когда `user` присвоено значение:

```js run
let user = "Иван";

alert(user ?? "Аноним"); // Иван (user существует)
```

Кроме этого, можно записать последовательность из операторов `??`, чтобы получить первое значение из списка, которое не является `null/undefined`.

Допустим, у нас есть данные пользователя в переменных `firstName`, `lastName` или `nickName`. Все они могут не существовать, если пользователь решил не вводить соответствующие значение.

Мы хотели бы отобразить имя пользователя, используя одну из этих переменных, или показать "Аноним", если все они `null/undefined`.

Для этого воспользуемся оператором `??`:

```js run
let firstName = null;
let lastName = null;
let nickName = "Суперкодер";

// показывает первое значение, которое определено:
*!*
alert(firstName ?? lastName ?? nickName ?? "Аноним"); // Суперкодер
*/!*
```

## Сравнение с ||

Оператор ИЛИ `||` можно использовать для того же, что и `??`, как это было показано в [предыдущей главе](info:logical-operators#or-finds-the-first-truthy-value).

Например, если в приведённом выше коде заменить `??` на `||`, то будет тот же самый результат:

```js run
let firstName = null;
let lastName = null;
let nickName = "Суперкодер";

// показывает первое истинное значение:
*!*
alert(firstName || lastName || nickName || "Аноним"); // Суперкодер
*/!*
```

Исторически сложилось так, что оператор ИЛИ `||` появился первым. Он существует с самого начала в JavaScript, поэтому разработчики долгое время использовали его для таких целей.

С другой стороны, сравнительно недавно в язык был добавлен оператор нулевого слияния `??` - как раз потому, что многие были недовольны оператором `||`.

Важное различие между ними заключается в том, что:
- `||` возвращает первое *истинное* значение.
- `??` возвращает первое *определённое* значение.

Проще говоря, оператор `||` не различает `false`, `0`, пустую строку `""` и `null/undefined`. Для него они все одинаковы, т.е. являются ложными значениями. Если первым аргументом для оператора `||` будет любое из перечисленных значений, то в качестве результата мы получим второй аргумент.

Однако на практике часто требуется использовать значение по умолчанию только тогда, когда переменная является `null/undefined`. Ведь именно тогда значение действительно неизвестно/не определено.

Рассмотрим следующий пример:

```js run
let height = 0;

alert(height || 100); // 100
alert(height ?? 100); // 0
```

- `height || 100` проверяет `height` на ложное значение, оно равно `0`, да, ложное.
    - поэтому результатом `||` является второй аргумент, т.е. `100`.
- `height ?? 100` проверяет, что переменная `height` содержит `null/undefined`, а поскольку это не так,
    - то результатом является сама переменная `height`, т.е. `0`.

На практике нулевая высота часто является вполне нормальным значением, которое не следует заменять значением по умолчанию. Таким образом, `??` здесь как раз работает так, как нужно.

## Приоритет

Приоритет оператора `??` такой же, как и у `||`. Они оба равны `3` в [таблице на MDN](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Operator_Precedence#Table).

Это означает, что, как и `||`, оператор нулевого слияния `??` вычисляется до `=` и `?`, но после большинства других операций, таких как `+`, `*`.

Так что, в выражениях такого вида понадобятся скобки:

```js run
let height = null;
let width = null;

// важно: используйте круглые скобки
let area = (height ?? 100) * (width ?? 50);

alert(area); // 5000
```

Иначе, если опустить скобки, оператор `*` выполнится первым, так как у него приоритет выше, чем у `??`, и это приведёт к неправильным результатам.

```js
// без скобок
let area = height ?? 100 * width ?? 50;

// ...сработает вот так (совсем не как нам нужно):
let area = height ?? (100 * width) ?? 50;
```

### Использование ?? вместе с && или ||

По соображениям безопасности JavaScript запрещает использование оператора `??` вместе с `&&` и `||`, если приоритет явно не указан при помощи круглых скобок.

Выполнение следующего кода приведёт к синтаксической ошибке:

```js run
let x = 1 && 2 ?? 3; // Синтаксическая ошибка
```

Это, безусловно спорное, ограничение было добавлено в спецификацию языка с целью избежать программные ошибки, когда люди начнут переходить с `||` на `??`.

Используйте скобки, чтобы обойти это ограничение:

```js run
*!*
let x = (1 && 2) ?? 3; // Работает без ошибок
*/!*

alert(x); // 2
```

</p>
</details>
<br/>

## Итого

- Оператор нулевого слияния `??` — это быстрый способ выбрать первое "определённое" значение из списка.

    Используется для присвоения переменным значений по умолчанию:

    ```js
    // будет height=100, если переменная height равна null или undefined
    height = height ?? 100;
    ```

- Оператор `??` имеет очень низкий приоритет, лишь немного выше, чем у `?` и `=`, поэтому при использовании его в выражении, скорее всего, потребуются скобки.
- Запрещено использовать вместе с `||` или `&&` без явно указанного приоритета, то есть без скобок.
<br/>

# 2.13 Циклы while и for

<details><summary><b>Ответ</b></summary>
<p>
При написании скриптов зачастую встаёт задача сделать однотипное действие много раз.

Например, вывести товары из списка один за другим. Или просто перебрать все числа от `1` до `10` и для каждого выполнить одинаковый код.

Для многократного повторения одного участка кода предусмотрены *циклы*.

```smart header="Циклы for..of и for..in"
Небольшое объявление для продвинутых читателей.

В этой статье рассматриваются только базовые циклы: `while`, `do..while` и `for(..;..;..)`.

Если вы пришли к этой статье в поисках других типов циклов, вот указатели:

- См. [for..in](info:object#forin) для перебора свойств объекта.
- См. [for..of](info:array#loops) и [Перебираемые объекты](info:iterable) для перебора массивов и перебираемых объектов.

В противном случае, продолжайте читать.
```

## Цикл "while"

Цикл `while` имеет следующий синтаксис:

```js
while (condition) {
  // код
  // также называемый "телом цикла"
}
```

Код из тела цикла выполняется, пока условие `condition` истинно.

Например, цикл ниже выводит `i`, пока `i < 3`:

```js run
let i = 0;
while (i < 3) { // выводит 0, затем 1, затем 2
  alert( i );
  i++;
}
```

Одно выполнение тела цикла по-научному называется *итерация*. Цикл в примере выше совершает три итерации.

Если бы строка `i++` отсутствовала в примере выше, то цикл бы повторялся (в теории) вечно. На практике, конечно, браузер не позволит такому случиться, он предоставит пользователю возможность остановить "подвисший" скрипт, а JavaScript на стороне сервера придётся "убить" процесс.

Любое выражение или переменная может быть условием цикла, а не только сравнение: условие `while` вычисляется и преобразуется в логическое значение.

Например, `while (i)` -- более краткий вариант `while (i != 0)`:

```js run
let i = 3;
*!*
while (i) { // когда i будет равно 0, условие станет ложным, и цикл остановится
*/!*
  alert( i );
  i--;
}
```

````smart header="Фигурные скобки не требуются для тела цикла из одной строки"
Если тело цикла состоит лишь из одной инструкции, мы можем опустить фигурные скобки `{…}`:

```js run
let i = 3;
*!*
while (i) alert(i--);
*/!*
```
````

## Цикл "do…while"

Проверку условия можно разместить под телом цикла, используя специальный синтаксис `do..while`:

```js
do {
  // тело цикла
} while (condition);
```

Цикл сначала выполнит тело, а затем проверит условие `condition`, и пока его значение равно `true`, он будет выполняться снова и снова.

Например:

```js run
let i = 0;
do {
  alert( i );
  i++;
} while (i < 3);
```

Такая форма синтаксиса оправдана, если вы хотите, чтобы тело цикла выполнилось **хотя бы один раз**, даже если условие окажется ложным. На практике чаще используется форма с предусловием: `while(…) {…}`.

## Цикл "for"

Более сложный, но при этом самый распространённый цикл — цикл `for`.

Выглядит он так:

```js
for (начало; условие; шаг) {
  // ... тело цикла ...
}
```

Давайте разберёмся, что означает каждая часть, на примере. Цикл ниже выполняет `alert(i)` для `i` от `0` до (но не включая) `3`:

```js run
for (let i = 0; i < 3; i++) { // выведет 0, затем 1, затем 2
  alert(i);
}
```

Рассмотрим конструкцию `for` подробней:

| часть  |          |                                                                            |
|-------|----------|----------------------------------------------------------------------------|
| начало | `let i = 0`    | Выполняется один раз при входе в цикл                                      |
| условие | `i < 3`| Проверяется *перед* каждой итерацией цикла. Если оно вычислится в `false`, цикл остановится.              |
| тело | `alert(i)`      | Выполняется снова и снова, пока условие вычисляется в `true`. |
| шаг | `i++`| Выполняется *после* тела цикла на каждой итерации *перед* проверкой условия.                         |

В целом, алгоритм работы цикла выглядит следующим образом:

```
Выполнить начало
→ (Если условие == true → Выполнить тело, Выполнить шаг)
→ (Если условие == true → Выполнить тело, Выполнить шаг)
→ (Если условие == true → Выполнить тело, Выполнить шаг)
→ ...
```

То есть, `начало` выполняется один раз, а затем каждая итерация заключается в проверке `условия`, после которой выполняется `тело` и `шаг`.

Если тема циклов для вас нова, может быть полезным вернуться к примеру выше и воспроизвести его работу на листе бумаги, шаг за шагом.

Вот в точности то, что происходит в нашем случае:

```js
// for (let i = 0; i < 3; i++) alert(i)

// Выполнить начало
let i = 0;
// Если условие == true → Выполнить тело, Выполнить шаг
if (i < 3) { alert(i); i++ }
// Если условие == true → Выполнить тело, Выполнить шаг
if (i < 3) { alert(i); i++ }
// Если условие == true → Выполнить тело, Выполнить шаг
if (i < 3) { alert(i); i++ }
// ...конец, потому что теперь i == 3
```

````smart header="Встроенное объявление переменной"
В примере переменная счётчика `i` была объявлена прямо в цикле. Это так называемое "встроенное" объявление переменной. Такие переменные существуют только внутри цикла.

```js run
for (*!*let*/!* i = 0; i < 3; i++) {
  alert(i); // 0, 1, 2
}
alert(i); // ошибка, нет такой переменной
```

Вместо объявления новой переменной мы можем использовать уже существующую:

```js run
let i = 0;

for (i = 0; i < 3; i++) { // используем существующую переменную
  alert(i); // 0, 1, 2
}

alert(i); // 3, переменная доступна, т.к. была объявлена снаружи цикла
```
````

### Пропуск частей "for"

Любая часть `for` может быть пропущена.

Для примера, мы можем пропустить `начало` если нам ничего не нужно делать перед стартом цикла.

Вот так:

```js run
let i = 0; // мы уже имеем объявленную i с присвоенным значением

for (; i < 3; i++) { // нет необходимости в "начале"
  alert( i ); // 0, 1, 2
}
```

Можно убрать и `шаг`:

```js run
let i = 0;

for (; i < 3;) {
  alert( i++ );
}
```

Это сделает цикл аналогичным `while (i < 3)`.

А можно и вообще убрать всё, получив бесконечный цикл:

```js
for (;;) {
  // будет выполняться вечно
}
```

При этом сами точки с запятой `;` обязательно должны присутствовать, иначе будет ошибка синтаксиса.

## Прерывание цикла: "break"

Обычно цикл завершается при вычислении *условия* в `false`.

Но мы можем выйти из цикла в любой момент с помощью специальной директивы `break`.

Например, следующий код подсчитывает сумму вводимых чисел до тех пор, пока посетитель их вводит, а затем – выдаёт:

```js run
let sum = 0;

while (true) {

  let value = +prompt("Введите число", '');

*!*
  if (!value) break; // (*)
*/!*

  sum += value;

}
alert( 'Сумма: ' + sum );
```

Директива `break` в строке `(*)` полностью прекращает выполнение цикла и передаёт управление на строку за его телом, то есть на `alert`.

Вообще, сочетание «бесконечный цикл + `break`» – отличная штука для тех ситуаций, когда условие, по которому нужно прерваться, находится не в начале или конце цикла, а посередине или даже в нескольких местах его тела.

## Переход к следующей итерации: continue [#continue]

Директива `continue` -- "облегчённая версия" `break`. При её выполнении цикл не прерывается, а переходит к следующей итерации (если условие все ещё равно `true`).

Её используют, если понятно, что на текущем повторе цикла делать больше нечего.

Например, цикл ниже использует `continue`, чтобы выводить только нечётные значения:

```js run no-beautify
for (let i = 0; i < 10; i++) {

  // если true, пропустить оставшуюся часть тела цикла
  *!*if (i % 2 == 0) continue;*/!*

  alert(i); // 1, затем 3, 5, 7, 9
}
```

Для чётных значений `i`, директива `continue` прекращает выполнение тела цикла и передаёт управление на следующую итерацию `for` (со следующим числом). Таким образом `alert` вызывается только для нечётных значений.

````smart header="Директива `continue` позволяет избегать вложенности"
Цикл, который обрабатывает только нечётные значения, мог бы выглядеть так:

```js run
for (let i = 0; i < 10; i++) {

  if (i % 2) {
    alert( i );
  }

}
```

С технической точки зрения он полностью идентичен. Действительно, вместо `continue` можно просто завернуть действия в блок `if`.

Однако мы получили дополнительный уровень вложенности фигурных скобок. Если код внутри `if` более длинный, то это ухудшает читаемость, в отличие от варианта с `continue`.
````

````warn header="Нельзя использовать `break/continue` справа от оператора '?'"
Обратите внимание, что эти синтаксические конструкции не являются выражениями и не могут быть использованы с тернарным оператором `?`. В частности, использование таких директив, как `break/continue`, вызовет ошибку.

Например, если мы возьмём этот код:

```js
if (i > 5) {
  alert(i);
} else {
  continue;
}
```

...и перепишем его, используя вопросительный знак:

```js no-beautify
(i > 5) ? alert(i) : *!*continue*/!*; // continue здесь приведёт к ошибке
```

...то будет синтаксическая ошибка.

Это ещё один повод не использовать оператор вопросительного знака `?` вместо `if`.
````

## Метки для break/continue

Бывает, нужно выйти одновременно из нескольких уровней цикла сразу.

Например, в коде ниже мы проходимся циклами по `i` и `j`, запрашивая с помощью `prompt` координаты `(i, j)` с `(0,0)` до `(2,2)`:

```js run no-beautify
for (let i = 0; i < 3; i++) {

  for (let j = 0; j < 3; j++) {

    let input = prompt(`Значение на координатах (${i},${j})`, '');

    // Что если мы захотим перейти к Готово (ниже) прямо отсюда?
  }
}

alert('Готово!');
```

Нам нужен способ остановить выполнение, если пользователь отменит ввод.

Обычный `break` после `input` лишь прервёт внутренний цикл, но этого недостаточно. Достичь желаемого поведения можно с помощью меток.

*Метка* имеет вид идентификатора с двоеточием перед циклом:

```js
labelName: for (...) {
  ...
}
```

Вызов `break <labelName>` в цикле ниже ищет ближайший внешний цикл с такой меткой и переходит в его конец.

```js run no-beautify
*!*outer:*/!* for (let i = 0; i < 3; i++) {

  for (let j = 0; j < 3; j++) {

    let input = prompt(`Значение на координатах (${i},${j})`, '');

    // если пустая строка или Отмена, то выйти из обоих циклов
    if (!input) *!*break outer*/!*; // (*)

    // сделать что-нибудь со значениями...
  }
}

alert('Готово!');
```

В примере выше это означает, что вызовом `break outer` будет разорван внешний цикл до метки с именем `outer`.

Таким образом управление перейдёт со строки, помеченной `(*)`, к `alert('Готово!')`.

Можно размещать метку на отдельной строке:

```js no-beautify
outer:
for (let i = 0; i < 3; i++) { ... }
```

Директива `continue` также может быть использована с меткой. В этом случае управление перейдёт на следующую итерацию цикла с меткой.

````warn header="Метки не позволяют \"прыгнуть\" куда угодно"
Метки не дают возможности передавать управление в произвольное место кода.

Например, нет возможности сделать следующее:

```js
break label; // не прыгает к метке ниже

label: for (...)
```

Директива `break` должна находиться внутри блока кода. Технически, подойдет любой маркированный блок кода, например:

```js
label: {
  // ...
  break label; // работает
  // ...
}
```

...Хотя в 99.9% случаев `break` используется внутри циклов, как мы видели в примерах выше.

К слову, `continue` возможно только внутри цикла.
````

</p>
</details>

## Итого

Мы рассмотрели 3 вида циклов:

- `while` -- Проверяет условие перед каждой итерацией.
- `do..while` -- Проверяет условие после каждой итерации.
- `for (;;)` -- Проверяет условие перед каждой итерацией, есть возможность задать дополнительные настройки.

Чтобы организовать бесконечный цикл, используют конструкцию `while (true)`. При этом он, как и любой другой цикл, может быть прерван директивой `break`.

Если на данной итерации цикла делать больше ничего не надо, но полностью прекращать цикл не следует – используют директиву `continue`.

Обе этих директивы поддерживают *метки*, которые ставятся перед циклом. Метки – единственный способ для `break/continue` выйти за пределы текущего цикла, повлиять на выполнение внешнего.

Заметим, что метки не позволяют прыгнуть в произвольное место кода, в JavaScript нет такой возможности.
<br/>

<br/>

# 2.14 Конструкция "switch"

<details><summary><b>Ответ</b></summary>
<p>


Конструкция `switch` заменяет собой сразу несколько `if`.

Она представляет собой более наглядный способ сравнить выражение сразу с несколькими вариантами.

## Синтаксис

Конструкция `switch` имеет один или более блок `case` и необязательный блок `default`.

Выглядит она так:

```js no-beautify
switch(x) {
  case 'value1':  // if (x === 'value1')
    ...
    [break]

  case 'value2':  // if (x === 'value2')
    ...
    [break]

  default:
    ...
    [break]
}
```

- Переменная `x` проверяется на строгое равенство первому значению `value1`, затем второму `value2` и так далее.
- Если соответствие установлено – `switch` начинает выполняться от соответствующей директивы `case` и далее, до ближайшего `break` (или до конца `switch`).
- Если ни один `case` не совпал – выполняется (если есть) вариант `default`.

## Пример работы

Пример использования `switch` (сработавший код выделен):

```js run
let a = 2 + 2;

switch (a) {
  case 3:
    alert( 'Маловато' );
    break;
*!*
  case 4:
    alert( 'В точку!' );
    break;
*/!*
  case 5:
    alert( 'Перебор' );
    break;
  default:
    alert( "Нет таких значений" );
}
```

Здесь оператор `switch` последовательно сравнит `a` со всеми вариантами из `case`.

Сначала `3`, затем – так как нет совпадения – `4`. Совпадение найдено, будет выполнен этот вариант, со строки `alert( 'В точку!' )` и далее, до ближайшего `break`, который прервёт выполнение.

**Если `break` нет, то выполнение пойдёт ниже по следующим `case`, при этом остальные проверки игнорируются.**

Пример без `break`:

```js run
let a = 2 + 2;

switch (a) {
  case 3:
    alert( 'Маловато' );
*!*
  case 4:
    alert( 'В точку!' );
  case 5:
    alert( 'Перебор' );
  default:
    alert( "Нет таких значений" );
*/!*
}
```

В примере выше последовательно выполнятся три `alert`:

```js
alert( 'В точку!' );
alert( 'Перебор' );
alert( "Нет таких значений" );
```

"Любое выражение может быть аргументом для `switch/case`"
И `switch` и `case` допускают любое выражение в качестве аргумента.

Например:

```js run
let a = "1";
let b = 0;

switch (+a) {
*!*
  case b + 1:
    alert("Выполнится, т.к. значением +a будет 1, что в точности равно b+1");
    break;
*/!*

  default:
    alert("Это не выполнится");
}

```
В этом примере выражение `+a` вычисляется в `1`, что совпадает с выражением `b + 1` в `case`, и следовательно, код в этом блоке будет выполнен.



## Группировка "case"

Несколько вариантов `case`, использующих один код, можно группировать.

Для примера, выполним один и тот же код для `case 3` и `case 5`, сгруппировав их:

```js run no-beautify
let a = 3;

switch (a) {
  case 4:
    alert('Правильно!');
    break;

*!*
  case 3: // (*) группируем оба case
  case 5:
    alert('Неправильно!');
    alert("Может вам посетить урок математики?");
    break;
*/!*

  default:
    alert('Результат выглядит странновато. Честно.');
}
```

Теперь оба варианта `3` и `5` выводят одно сообщение.

Возможность группировать `case` – это побочный эффект того, как `switch/case` работает без `break`. Здесь выполнение `case 3` начинается со строки `(*)` и продолжается в `case 5`, потому что отсутствует `break`.

## Тип имеет значение

Нужно отметить, что проверка на равенство всегда строгая. Значения должны быть одного типа, чтобы выполнялось равенство.

Для примера, давайте рассмотрим следующий код:

```js run
let arg = prompt("Введите число?");
switch (arg) {
  case '0':
  case '1':
    alert( 'Один или ноль' );
    break;

  case '2':
    alert( 'Два' );
    break;

  case 3:
    alert( 'Никогда не выполнится!' );
    break;
  default:
    alert( 'Неизвестное значение' );
}
```

1. Для `'0'` и `'1'` выполнится первый `alert`.
2. Для `'2'` -- второй `alert`.
3. Но для `3`, результат выполнения `prompt` будет строка `"3"`, которая не соответствует строгому равенству `===` с числом `3`. Таким образом, мы имеем "мёртвый код" в `case 3`! Выполнится вариант `default`.
</p>
</details>
<br/>

<br/>

# 2.15 Функции

<details><summary><b>Ответ</b></summary>
<p>
Зачастую нам надо повторять одно и то же действие во многих частях программы.

Например, необходимо красиво вывести сообщение при приветствии посетителя, при выходе посетителя с сайта, ещё где-нибудь.

Чтобы не повторять один и тот же код во многих местах, придуманы функции. Функции являются основными «строительными блоками» программы.

Примеры встроенных функций вы уже видели – это `alert(message)`, `prompt(message, default)` и `confirm(question)`. Но можно создавать и свои.

## Объявление функции

Для создания функций мы можем использовать *объявление функции*.

Пример объявления функции:

```js
function showMessage() {
  alert( 'Всем привет!' );
}
```

Вначале идёт ключевое слово `function`, после него *имя функции*, затем список *параметров* в круглых скобках через запятую (в вышеприведённом примере он пустой) и, наконец, код функции, также называемый "телом функции", внутри фигурных скобок.

```js
function имя(параметры) {
  ...тело...
}
```

Наша новая функция может быть вызвана по своему имени: `showMessage()`.

Например:

```js run
function showMessage() {
  alert( 'Всем привет!' );
}

*!*
showMessage();
showMessage();
*/!*
```

Вызов `showMessage()` выполняет код функции. Здесь мы увидим сообщение дважды.

Этот пример явно демонстрирует одно из главных предназначений функций: избавление от дублирования кода.

Если понадобится поменять сообщение или способ его вывода – достаточно изменить его в одном месте: в функции, которая его выводит.

## Локальные переменные

Переменные, объявленные внутри функции, видны только внутри этой функции.

Например:

```js run
function showMessage() {
*!*
  let message = "Привет, я JavaScript!"; // локальная переменная
*/!*

  alert( message );
}

showMessage(); // Привет, я JavaScript!

alert( message ); // <-- будет ошибка, т.к. переменная видна только внутри функции
```

## Внешние переменные

У функции есть доступ к внешним переменным, например:

```js run no-beautify
let *!*userName*/!* = 'Вася';

function showMessage() {
  let message = 'Привет, ' + *!*userName*/!*;
  alert(message);
}

showMessage(); // Привет, Вася
```

Функция обладает полным доступом к внешним переменным и может изменять их значение.

Например:

```js run
let *!*userName*/!* = 'Вася';

function showMessage() {
  *!*userName*/!* = "Петя"; // (1) изменяем значение внешней переменной

  let message = 'Привет, ' + *!*userName*/!*;
  alert(message);
}

alert( userName ); // *!*Вася*/!* перед вызовом функции

showMessage();

alert( userName ); // *!*Петя*/!*, значение внешней переменной было изменено функцией
```

Внешняя переменная используется, только если внутри функции нет такой локальной.

Если одноимённая переменная объявляется внутри функции, тогда она перекрывает внешнюю. Например, в коде ниже функция использует локальную переменную `userName`. Внешняя будет проигнорирована:

```js run
let userName = 'Вася';

function showMessage() {
*!*
  let userName = "Петя"; // объявляем локальную переменную
*/!*

  let message = 'Привет, ' + userName; // *!*Петя*/!*
  alert(message);
}

// функция создаст и будет использовать свою собственную локальную переменную userName
showMessage();

alert( userName ); // *!*Вася*/!*, не изменилась, функция не трогала внешнюю переменную
```

```smart header="Глобальные переменные"
Переменные, объявленные снаружи всех функций, такие как внешняя переменная `userName` в вышеприведённом коде -- называются *глобальными*.

*Глобальные переменные* видимы для любой функции (если только их не перекрывают одноимённые локальные переменные).

Желательно сводить использование глобальных переменных к минимуму. В современном коде обычно мало или совсем нет глобальных переменных. Хотя они иногда полезны для хранения важнейших "общепроектовых" данных.
```

## Параметры

Мы можем передать внутрь функции любую информацию, используя параметры (также называемые *аргументами функции*).

В нижеприведённом примере функции передаются два параметра: `from` и `text`.

```js run
function showMessage(*!*from, text*/!*) { // аргументы: from, text
  alert(from + ': ' + text);
}

*!*
showMessage('Аня', 'Привет!'); // Аня: Привет! (*)
showMessage('Аня', "Как дела?"); // Аня: Как дела? (**)
*/!*
```

Когда функция вызывается в строках `(*)` и `(**)`, переданные значения копируются в локальные переменные `from` и `text`. Затем они используются в теле функции.

Вот ещё один пример: у нас есть переменная `from`, и мы передаём её функции. Обратите внимание: функция изменяет значение `from`, но это изменение не видно снаружи. Функция всегда получает только копию значения:


```js run
function showMessage(from, text) {

*!*
  from = '*' + from + '*'; // немного украсим "from"
*/!*

  alert( from + ': ' + text );
}

let from = "Аня";

showMessage(from, "Привет"); // *Аня*: Привет

// значение "from" осталось прежним, функция изменила значение локальной переменной
alert( from ); // Аня
```

Значение, передаваемое в качестве параметра функции, также называется *аргументом*.

Другими словами:

Параметр - это переменная, указанная в круглых скобках в объявлении функции.
Аргумент - это значение, которое передаётся функции при её вызове.

Мы объявляем функции со списком параметров, затем вызываем их, передавая аргументы.

В приведённом выше примере можно было бы сказать: "функция `showMessage` объявляется с двумя параметрами, затем вызывается с двумя аргументами: `from` и `"Привет"`".

## Параметры по умолчанию

Если параметр не указан, то его значением становится `undefined`.

Например, вышеупомянутая функция `showMessage(from, text)` может быть вызвана с одним аргументом:

```js
showMessage("Аня");
```

Это не приведёт к ошибке. Такой вызов выведет `"*Аня*: undefined"`. В вызове не указан параметр `text`, поэтому предполагается, что `text === undefined`.

Если мы хотим задать параметру `text` значение по умолчанию, мы должны указать его после `=`:

```js run
function showMessage(from, *!*text = "текст не добавлен"*/!*) {
  alert( from + ": " + text );
}

showMessage("Аня"); // Аня: текст не добавлен
```

Теперь, если параметр `text` не указан, его значением будет `"текст не добавлен"`

В данном случае `"текст не добавлен"` это строка, но на её месте могло бы быть и более сложное выражение, которое бы вычислялось и присваивалось при отсутствии параметра. Например:

```js run
function showMessage(from, text = anotherFunction()) {
  // anotherFunction() выполнится только если не передан text
  // результатом будет значение text
}
```

```smart header="Вычисление параметров по умолчанию"
В JavaScript параметры по умолчанию вычисляются каждый раз, когда функция вызывается без соответствующего параметра.

В приведённом выше примере, функция `anotherFunction()` не будет вызвана вообще, если указан параметр `text`.

С другой стороны, функция будет независимо вызываться каждый раз, когда `text` отсутствует.
```

````smart header="Использование параметров по умолчанию в ранних версиях JavaScript"
Ранние версии JavaScript не поддерживали параметры по умолчанию. Поэтому существуют альтернативные способы, которые могут встречаться в старых скриптах.

Например, явная проверка на `undefined`:

```js
function showMessage(from, text) {
*!*
  if (text === undefined) {
    text = 'текст не добавлен';
  }
*/!*

  alert( from + ": " + text );
}
```

...Или с помощью оператора `||`:

```js
function showMessage(from, text) {
  // Если значение text ложно, тогда присвоить параметру text значение по умолчанию
  // заметим, что при этом пустая строка text === "" будет также считаться отсутствующим значением
  text = text || 'текст не добавлен';
  ...
}
```
````

### Альтернативные параметры по умолчанию

Иногда имеет смысл присваивать значения по умолчанию для параметров не в объявлении функции, а на более позднем этапе.

Во время выполнения функции мы можем проверить, передан ли параметр, сравнив его с `undefined`:

```js run
function showMessage(text) {
  // ...
*!*
  if (text === undefined) { // если параметр отсутствует
    text = 'пустое сообщение';
  }
*/!*
  alert(text);
}
showMessage(); // пустое сообщение
```

...Или мы можем использовать оператор `||`:

```js
function showMessage(text) {
  // если значение text ложно или равняется undefined, тогда присвоить text значение 'пусто'
  text = text || 'пусто';
  ...
}
```

Современные движки JavaScript поддерживают [оператор нулевого слияния](info:nullish-coalescing-operator) `??`. Его использование будет лучшей практикой, в случае, если большинство ложных значений, таких как `0`, следует расценивать как "нормальные".

```js run
function showCount(count) {
  // если count равен undefined или null, показать "неизвестно"
  alert(count ?? "неизвестно");
}
showCount(0); // 0
showCount(null); // неизвестно
showCount(); // неизвестно
```

## Возврат значения

Функция может вернуть результат, который будет передан в вызвавший её код.

Простейшим примером может служить функция сложения двух чисел:

```js run no-beautify
function sum(a, b) {
  *!*return*/!* a + b;
}

let result = sum(1, 2);
alert( result ); // 3
```

Директива `return` может находиться в любом месте тела функции. Как только выполнение доходит до этого места, функция останавливается, и значение возвращается в вызвавший её код (присваивается переменной `result` выше).

Вызовов `return` может быть несколько, например:

```js run
function checkAge(age) {
  if (age > 18) {
*!*
    return true;
*/!*
  } else {
*!*
    return confirm('А родители разрешили?');
*/!*
  }
}

let age = prompt('Сколько вам лет?', 18);

if ( checkAge(age) ) {
  alert( 'Доступ получен' );
} else {
  alert( 'Доступ закрыт' );
}
```

Возможно использовать `return` и без значения. Это приведёт к немедленному выходу из функции.

Например:

```js
function showMovie(age) {
  if ( !checkAge(age) ) {
*!*
    return;
*/!*
  }

  alert( "Вам показывается кино" ); // (*)
  // ...
}
```

В коде выше, если `checkAge(age)` вернёт `false`, `showMovie` не выполнит `alert`.

````smart header="Результат функции с пустым `return` или без него - `undefined`"
Если функция не возвращает значения, это всё равно, как если бы она возвращала `undefined`:

```js run
function doNothing() { /* пусто */ }

alert( doNothing() === undefined ); // true
```

Пустой `return` аналогичен `return undefined`:

```js run
function doNothing() {
  return;
}

alert( doNothing() === undefined ); // true
```
````

````warn header="Никогда не добавляйте перевод строки между `return` и его значением"
Для длинного выражения в `return` может быть заманчиво разместить его на нескольких отдельных строках, например так:

```js
return
 (some + long + expression + or + whatever * f(a) + f(b))
```
Код не выполнится, потому что интерпретатор JavaScript подставит точку с запятой после `return`. Для него это будет выглядеть так:

```js
return*!*;*/!*
 (some + long + expression + or + whatever * f(a) + f(b))
```

Таким образом, это фактически стало пустым `return`.

Если мы хотим, чтобы возвращаемое выражение занимало несколько строк, нужно начать его на той же строке, что и `return`. Или, хотя бы, поставить там открывающую скобку, вот так:

```js
return (
  some + long + expression
  + or +
  whatever * f(a) + f(b)
  )
```

И тогда всё сработает, как задумано.
````

## Выбор имени функции [#function-naming]

Функция - это действие. Поэтому имя функции обычно является глаголом. Оно должно быть кратким, точным и описывать действие функции, чтобы программист, который будет читать код, получил верное представление о том, что делает функция.

Как правило, используются глагольные префиксы, обозначающие общий характер действия, после которых следует уточнение. Обычно в командах разработчиков действуют соглашения, касающиеся значений этих префиксов.

Например, функции, начинающиеся с `"show"` обычно что-то показывают.

Функции, начинающиеся с...

- `"get…"` -- возвращают значение,
- `"calc…"` -- что-то вычисляют,
- `"create…"` -- что-то создают,
- `"check…"` -- что-то проверяют и возвращают логическое значение, и т.д.

Примеры таких имён:

```js no-beautify
showMessage(..)     // показывает сообщение
getAge(..)          // возвращает возраст (получая его каким-то образом)
calcSum(..)         // вычисляет сумму и возвращает результат
createForm(..)      // создаёт форму (и обычно возвращает её)
checkPermission(..) // проверяет доступ, возвращая true/false
```

Благодаря префиксам, при первом взгляде на имя функции становится понятным, что делает её код, и какое значение она может возвращать.

```smart header="Одна функция -- одно действие"
Функция должна делать только то, что явно подразумевается её названием. И это должно быть одним действием.

Два независимых действия обычно подразумевают две функции, даже если предполагается, что они будут вызываться вместе (в этом случае мы можем создать третью функцию, которая будет их вызывать).

Несколько примеров, которые нарушают это правило:

- `getAge` -- будет плохим выбором, если функция будет выводить `alert` с возрастом (должна только возвращать его).
- `createForm` -- будет плохим выбором, если функция будет изменять документ, добавляя форму в него (должна только создавать форму и возвращать её).
- `checkPermission` -- будет плохим выбором, если функция будет отображать сообщение с текстом `доступ разрешён/запрещён` (должна только выполнять проверку и возвращать её результат).

В этих примерах использовались общепринятые смыслы префиксов. Конечно, вы в команде можете договориться о других значениях, но обычно они мало отличаются от общепринятых. В любом случае вы и ваша команда должны чётко понимать, что значит префикс, что функция с ним может делать, а чего не может.
```

```smart header="Сверхкороткие имена функций"
Имена функций, которые используются *очень часто*, иногда делают сверхкороткими.

Например, фреймворк [jQuery](http://jquery.com) определяет функцию с помощью `$`. В библиотеке [Lodash](http://lodash.com/) основная функция представлена именем `_`.

Это исключения. В основном имена функций должны быть в меру краткими и описательными.
```

## Функции == Комментарии

Функции должны быть короткими и делать только что-то одно. Если это что-то большое, имеет смысл разбить функцию на несколько меньших. Иногда следовать этому правилу непросто, но это определённо хорошее правило.

Небольшие функции не только облегчают тестирование и отладку -- само существование таких функций выполняет роль хороших комментариев!

Например, сравним ниже две функции `showPrimes(n)`. Каждая из них выводит [простое число](https://ru.wikipedia.org/wiki/%D0%9F%D1%80%D0%BE%D1%81%D1%82%D0%BE%D0%B5_%D1%87%D0%B8%D1%81%D0%BB%D0%BE) до `n`.

Первый вариант использует метку `nextPrime`:

```js
function showPrimes(n) {
  nextPrime: for (let i = 2; i < n; i++) {

    for (let j = 2; j < i; j++) {
      if (i % j == 0) continue nextPrime;
    }

    alert( i ); // простое
  }
}
```

Второй вариант использует дополнительную функцию `isPrime(n)` для проверки на простое:

```js
function showPrimes(n) {

  for (let i = 2; i < n; i++) {
    *!*if (!isPrime(i)) continue;*/!*

    alert(i);  // простое
  }
}

function isPrime(n) {
  for (let i = 2; i < n; i++) {
    if ( n % i == 0) return false;
  }
  return true;
}
```

Второй вариант легче для понимания, не правда ли? Вместо куска кода мы видим название действия (`isPrime`). Иногда разработчики называют такой код *самодокументируемым*.

Таким образом, допустимо создавать функции, даже если мы не планируем повторно использовать их. Такие функции структурируют код и делают его более понятным.

</p>
</details>
<br/>

## Итого

Объявление функции имеет вид:

```js
function имя(параметры, через, запятую) {
  /* тело, код функции */
}
```

- Передаваемые значения копируются в параметры функции и становятся локальными переменными.
- Функции имеют доступ к внешним переменным. Но это работает только изнутри наружу. Код вне функции не имеет доступа к её локальным переменным.
- Функция может возвращать значение. Если этого не происходит, тогда результат равен `undefined`.
<br/>


# 2.16 Функции

<details><summary><b>Ответ</b></summary>
<p>

</p>
</details>
<br/>

<br/>